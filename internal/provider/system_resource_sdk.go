// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"encoding/json"
	tfTypes "github.com/StyraInc/terraform-provider-styra/internal/provider/types"
	"github.com/StyraInc/terraform-provider-styra/internal/sdk/models/shared"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"time"
)

func (r *SystemResourceModel) ToSharedSystemsV1SystemsPostRequest() *shared.SystemsV1SystemsPostRequest {
	var bundleDownload *shared.SystemsV1BundleDownloadConfig
	if r.BundleDownload != nil {
		deltaBundles := new(bool)
		if !r.BundleDownload.DeltaBundles.IsUnknown() && !r.BundleDownload.DeltaBundles.IsNull() {
			*deltaBundles = r.BundleDownload.DeltaBundles.ValueBool()
		} else {
			deltaBundles = nil
		}
		bundleDownload = &shared.SystemsV1BundleDownloadConfig{
			DeltaBundles: deltaBundles,
		}
	}
	var bundleRegistry *shared.SystemsV1BundleRegistryConfig
	if r.BundleRegistry != nil {
		disableBundleCompatibilityCheck := new(bool)
		if !r.BundleRegistry.DisableBundleCompatibilityCheck.IsUnknown() && !r.BundleRegistry.DisableBundleCompatibilityCheck.IsNull() {
			*disableBundleCompatibilityCheck = r.BundleRegistry.DisableBundleCompatibilityCheck.ValueBool()
		} else {
			disableBundleCompatibilityCheck = nil
		}
		var distributionS3 *shared.SystemsV1BundleDistributionS3Config
		if r.BundleRegistry.DistributionS3 != nil {
			accessKeys := new(string)
			if !r.BundleRegistry.DistributionS3.AccessKeys.IsUnknown() && !r.BundleRegistry.DistributionS3.AccessKeys.IsNull() {
				*accessKeys = r.BundleRegistry.DistributionS3.AccessKeys.ValueString()
			} else {
				accessKeys = nil
			}
			var bucket string
			bucket = r.BundleRegistry.DistributionS3.Bucket.ValueString()

			contextPath := new(string)
			if !r.BundleRegistry.DistributionS3.ContextPath.IsUnknown() && !r.BundleRegistry.DistributionS3.ContextPath.IsNull() {
				*contextPath = r.BundleRegistry.DistributionS3.ContextPath.ValueString()
			} else {
				contextPath = nil
			}
			discoveryPath := new(string)
			if !r.BundleRegistry.DistributionS3.DiscoveryPath.IsUnknown() && !r.BundleRegistry.DistributionS3.DiscoveryPath.IsNull() {
				*discoveryPath = r.BundleRegistry.DistributionS3.DiscoveryPath.ValueString()
			} else {
				discoveryPath = nil
			}
			endpoint := new(string)
			if !r.BundleRegistry.DistributionS3.Endpoint.IsUnknown() && !r.BundleRegistry.DistributionS3.Endpoint.IsNull() {
				*endpoint = r.BundleRegistry.DistributionS3.Endpoint.ValueString()
			} else {
				endpoint = nil
			}
			var opaCredentials *shared.SystemsV1BundleDistributionS3ConfigOpaCredentials
			if r.BundleRegistry.DistributionS3.OpaCredentials != nil {
				var environmentCredentials *shared.SystemsV1BundleDistributionS3ConfigOpaCredentialsEnvironmentCredentials
				if r.BundleRegistry.DistributionS3.OpaCredentials.EnvironmentCredentials != nil {
					environmentCredentials = &shared.SystemsV1BundleDistributionS3ConfigOpaCredentialsEnvironmentCredentials{}
				}
				var metadataCredentials *shared.SystemsV1BundleDistributionS3ConfigOpaCredentialsMetadataCredentials
				if r.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials != nil {
					var awsRegion string
					awsRegion = r.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials.AwsRegion.ValueString()

					iamRole := new(string)
					if !r.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials.IamRole.IsUnknown() && !r.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials.IamRole.IsNull() {
						*iamRole = r.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials.IamRole.ValueString()
					} else {
						iamRole = nil
					}
					metadataCredentials = &shared.SystemsV1BundleDistributionS3ConfigOpaCredentialsMetadataCredentials{
						AwsRegion: awsRegion,
						IamRole:   iamRole,
					}
				}
				var webIdentityCredentials *shared.SystemsV1BundleDistributionS3ConfigOpaCredentialsWebIdentityCredentials
				if r.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials != nil {
					var awsRegion1 string
					awsRegion1 = r.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials.AwsRegion.ValueString()

					var sessionName string
					sessionName = r.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials.SessionName.ValueString()

					webIdentityCredentials = &shared.SystemsV1BundleDistributionS3ConfigOpaCredentialsWebIdentityCredentials{
						AwsRegion:   awsRegion1,
						SessionName: sessionName,
					}
				}
				opaCredentials = &shared.SystemsV1BundleDistributionS3ConfigOpaCredentials{
					EnvironmentCredentials: environmentCredentials,
					MetadataCredentials:    metadataCredentials,
					WebIdentityCredentials: webIdentityCredentials,
				}
			}
			policyPath := new(string)
			if !r.BundleRegistry.DistributionS3.PolicyPath.IsUnknown() && !r.BundleRegistry.DistributionS3.PolicyPath.IsNull() {
				*policyPath = r.BundleRegistry.DistributionS3.PolicyPath.ValueString()
			} else {
				policyPath = nil
			}
			var region string
			region = r.BundleRegistry.DistributionS3.Region.ValueString()

			roleArn := new(string)
			if !r.BundleRegistry.DistributionS3.RoleArn.IsUnknown() && !r.BundleRegistry.DistributionS3.RoleArn.IsNull() {
				*roleArn = r.BundleRegistry.DistributionS3.RoleArn.ValueString()
			} else {
				roleArn = nil
			}
			distributionS3 = &shared.SystemsV1BundleDistributionS3Config{
				AccessKeys:     accessKeys,
				Bucket:         bucket,
				ContextPath:    contextPath,
				DiscoveryPath:  discoveryPath,
				Endpoint:       endpoint,
				OpaCredentials: opaCredentials,
				PolicyPath:     policyPath,
				Region:         region,
				RoleArn:        roleArn,
			}
		}
		var entrypoints []string = []string{}
		for _, entrypointsItem := range r.BundleRegistry.Entrypoints {
			entrypoints = append(entrypoints, entrypointsItem.ValueString())
		}
		manualDeployment := new(bool)
		if !r.BundleRegistry.ManualDeployment.IsUnknown() && !r.BundleRegistry.ManualDeployment.IsNull() {
			*manualDeployment = r.BundleRegistry.ManualDeployment.ValueBool()
		} else {
			manualDeployment = nil
		}
		manualDeploymentOverrides := make(map[string]bool)
		for manualDeploymentOverridesKey, manualDeploymentOverridesValue := range r.BundleRegistry.ManualDeploymentOverrides {
			var manualDeploymentOverridesInst bool
			manualDeploymentOverridesInst = manualDeploymentOverridesValue.ValueBool()

			manualDeploymentOverrides[manualDeploymentOverridesKey] = manualDeploymentOverridesInst
		}
		maxBundles := new(int64)
		if !r.BundleRegistry.MaxBundles.IsUnknown() && !r.BundleRegistry.MaxBundles.IsNull() {
			*maxBundles = r.BundleRegistry.MaxBundles.ValueInt64()
		} else {
			maxBundles = nil
		}
		maxDeployedBundles := new(int64)
		if !r.BundleRegistry.MaxDeployedBundles.IsUnknown() && !r.BundleRegistry.MaxDeployedBundles.IsNull() {
			*maxDeployedBundles = r.BundleRegistry.MaxDeployedBundles.ValueInt64()
		} else {
			maxDeployedBundles = nil
		}
		optimizationLevel := new(int)
		if !r.BundleRegistry.OptimizationLevel.IsUnknown() && !r.BundleRegistry.OptimizationLevel.IsNull() {
			*optimizationLevel = int(r.BundleRegistry.OptimizationLevel.ValueInt64())
		} else {
			optimizationLevel = nil
		}
		bundleRegistry = &shared.SystemsV1BundleRegistryConfig{
			DisableBundleCompatibilityCheck: disableBundleCompatibilityCheck,
			DistributionS3:                  distributionS3,
			Entrypoints:                     entrypoints,
			ManualDeployment:                manualDeployment,
			ManualDeploymentOverrides:       manualDeploymentOverrides,
			MaxBundles:                      maxBundles,
			MaxDeployedBundles:              maxDeployedBundles,
			OptimizationLevel:               optimizationLevel,
		}
	}
	contextBundleDataOnly := new(bool)
	if !r.ContextBundleDataOnly.IsUnknown() && !r.ContextBundleDataOnly.IsNull() {
		*contextBundleDataOnly = r.ContextBundleDataOnly.ValueBool()
	} else {
		contextBundleDataOnly = nil
	}
	var contextBundleRoots []string = []string{}
	for _, contextBundleRootsItem := range r.ContextBundleRoots {
		contextBundleRoots = append(contextBundleRoots, contextBundleRootsItem.ValueString())
	}
	decisionMappings := make(map[string]shared.SystemsV1RuleDecisionMappings)
	for decisionMappingsKey, decisionMappingsValue := range r.DecisionMappings {
		var allowed *shared.SystemsV1AllowedMapping
		if decisionMappingsValue.Allowed != nil {
			var expected interface{}
			if !decisionMappingsValue.Allowed.Expected.IsUnknown() && !decisionMappingsValue.Allowed.Expected.IsNull() {
				_ = json.Unmarshal([]byte(decisionMappingsValue.Allowed.Expected.ValueString()), &expected)
			}
			negated := new(bool)
			if !decisionMappingsValue.Allowed.Negated.IsUnknown() && !decisionMappingsValue.Allowed.Negated.IsNull() {
				*negated = decisionMappingsValue.Allowed.Negated.ValueBool()
			} else {
				negated = nil
			}
			var path string
			path = decisionMappingsValue.Allowed.Path.ValueString()

			allowed = &shared.SystemsV1AllowedMapping{
				Expected: expected,
				Negated:  negated,
				Path:     path,
			}
		}
		var columns []shared.SystemsV1ColumnMapping = []shared.SystemsV1ColumnMapping{}
		for _, columnsItem := range decisionMappingsValue.Columns {
			var key string
			key = columnsItem.Key.ValueString()

			var path1 string
			path1 = columnsItem.Path.ValueString()

			typeVar := new(string)
			if !columnsItem.Type.IsUnknown() && !columnsItem.Type.IsNull() {
				*typeVar = columnsItem.Type.ValueString()
			} else {
				typeVar = nil
			}
			columns = append(columns, shared.SystemsV1ColumnMapping{
				Key:  key,
				Path: path1,
				Type: typeVar,
			})
		}
		var reason *shared.SystemsV1ReasonMapping
		if decisionMappingsValue.Reason != nil {
			var path2 string
			path2 = decisionMappingsValue.Reason.Path.ValueString()

			reason = &shared.SystemsV1ReasonMapping{
				Path: path2,
			}
		}
		decisionMappingsInst := shared.SystemsV1RuleDecisionMappings{
			Allowed: allowed,
			Columns: columns,
			Reason:  reason,
		}
		decisionMappings[decisionMappingsKey] = decisionMappingsInst
	}
	var deploymentParameters *shared.SystemsV1SystemDeploymentParameters
	if r.DeploymentParameters != nil {
		denyOnOpaFail := new(bool)
		if !r.DeploymentParameters.DenyOnOpaFail.IsUnknown() && !r.DeploymentParameters.DenyOnOpaFail.IsNull() {
			*denyOnOpaFail = r.DeploymentParameters.DenyOnOpaFail.ValueBool()
		} else {
			denyOnOpaFail = nil
		}
		var discovery *shared.Discovery
		if r.DeploymentParameters.Discovery != nil {
			discovery = &shared.Discovery{}
		}
		var extra *shared.Extra
		if r.DeploymentParameters.Extra != nil {
			extra = &shared.Extra{}
		}
		httpProxy := new(string)
		if !r.DeploymentParameters.HTTPProxy.IsUnknown() && !r.DeploymentParameters.HTTPProxy.IsNull() {
			*httpProxy = r.DeploymentParameters.HTTPProxy.ValueString()
		} else {
			httpProxy = nil
		}
		httpsProxy := new(string)
		if !r.DeploymentParameters.HTTPSProxy.IsUnknown() && !r.DeploymentParameters.HTTPSProxy.IsNull() {
			*httpsProxy = r.DeploymentParameters.HTTPSProxy.ValueString()
		} else {
			httpsProxy = nil
		}
		kubernetesVersion := new(string)
		if !r.DeploymentParameters.KubernetesVersion.IsUnknown() && !r.DeploymentParameters.KubernetesVersion.IsNull() {
			*kubernetesVersion = r.DeploymentParameters.KubernetesVersion.ValueString()
		} else {
			kubernetesVersion = nil
		}
		mutatingWebhookName := new(string)
		if !r.DeploymentParameters.MutatingWebhookName.IsUnknown() && !r.DeploymentParameters.MutatingWebhookName.IsNull() {
			*mutatingWebhookName = r.DeploymentParameters.MutatingWebhookName.ValueString()
		} else {
			mutatingWebhookName = nil
		}
		namespace := new(string)
		if !r.DeploymentParameters.Namespace.IsUnknown() && !r.DeploymentParameters.Namespace.IsNull() {
			*namespace = r.DeploymentParameters.Namespace.ValueString()
		} else {
			namespace = nil
		}
		noProxy := new(string)
		if !r.DeploymentParameters.NoProxy.IsUnknown() && !r.DeploymentParameters.NoProxy.IsNull() {
			*noProxy = r.DeploymentParameters.NoProxy.ValueString()
		} else {
			noProxy = nil
		}
		timeoutSeconds := new(int)
		if !r.DeploymentParameters.TimeoutSeconds.IsUnknown() && !r.DeploymentParameters.TimeoutSeconds.IsNull() {
			*timeoutSeconds = int(r.DeploymentParameters.TimeoutSeconds.ValueInt64())
		} else {
			timeoutSeconds = nil
		}
		var trustedCaCerts []string = []string{}
		for _, trustedCaCertsItem := range r.DeploymentParameters.TrustedCaCerts {
			trustedCaCerts = append(trustedCaCerts, trustedCaCertsItem.ValueString())
		}
		trustedContainerRegistry := new(string)
		if !r.DeploymentParameters.TrustedContainerRegistry.IsUnknown() && !r.DeploymentParameters.TrustedContainerRegistry.IsNull() {
			*trustedContainerRegistry = r.DeploymentParameters.TrustedContainerRegistry.ValueString()
		} else {
			trustedContainerRegistry = nil
		}
		deploymentParameters = &shared.SystemsV1SystemDeploymentParameters{
			DenyOnOpaFail:            denyOnOpaFail,
			Discovery:                discovery,
			Extra:                    extra,
			HTTPProxy:                httpProxy,
			HTTPSProxy:               httpsProxy,
			KubernetesVersion:        kubernetesVersion,
			MutatingWebhookName:      mutatingWebhookName,
			Namespace:                namespace,
			NoProxy:                  noProxy,
			TimeoutSeconds:           timeoutSeconds,
			TrustedCaCerts:           trustedCaCerts,
			TrustedContainerRegistry: trustedContainerRegistry,
		}
	}
	description := new(string)
	if !r.Description.IsUnknown() && !r.Description.IsNull() {
		*description = r.Description.ValueString()
	} else {
		description = nil
	}
	errorSetting := new(string)
	if !r.ErrorSetting.IsUnknown() && !r.ErrorSetting.IsNull() {
		*errorSetting = r.ErrorSetting.ValueString()
	} else {
		errorSetting = nil
	}
	var externalBundles *shared.SystemsV1ExternalBundleConfig
	if r.ExternalBundles != nil {
		bundles := make(map[string]shared.SystemsV1OpaConfigBundleDeclaration)
		for bundlesKey, bundlesValue := range r.ExternalBundles.Bundles {
			persist := new(bool)
			if !bundlesValue.Persist.IsUnknown() && !bundlesValue.Persist.IsNull() {
				*persist = bundlesValue.Persist.ValueBool()
			} else {
				persist = nil
			}
			var polling *shared.SystemsV1PollingConfig
			if bundlesValue.Polling != nil {
				longPollingTimeoutSeconds := new(int64)
				if !bundlesValue.Polling.LongPollingTimeoutSeconds.IsUnknown() && !bundlesValue.Polling.LongPollingTimeoutSeconds.IsNull() {
					*longPollingTimeoutSeconds = bundlesValue.Polling.LongPollingTimeoutSeconds.ValueInt64()
				} else {
					longPollingTimeoutSeconds = nil
				}
				maxDelaySeconds := new(int64)
				if !bundlesValue.Polling.MaxDelaySeconds.IsUnknown() && !bundlesValue.Polling.MaxDelaySeconds.IsNull() {
					*maxDelaySeconds = bundlesValue.Polling.MaxDelaySeconds.ValueInt64()
				} else {
					maxDelaySeconds = nil
				}
				minDelaySeconds := new(int64)
				if !bundlesValue.Polling.MinDelaySeconds.IsUnknown() && !bundlesValue.Polling.MinDelaySeconds.IsNull() {
					*minDelaySeconds = bundlesValue.Polling.MinDelaySeconds.ValueInt64()
				} else {
					minDelaySeconds = nil
				}
				polling = &shared.SystemsV1PollingConfig{
					LongPollingTimeoutSeconds: longPollingTimeoutSeconds,
					MaxDelaySeconds:           maxDelaySeconds,
					MinDelaySeconds:           minDelaySeconds,
				}
			}
			resource := new(string)
			if !bundlesValue.Resource.IsUnknown() && !bundlesValue.Resource.IsNull() {
				*resource = bundlesValue.Resource.ValueString()
			} else {
				resource = nil
			}
			var service string
			service = bundlesValue.Service.ValueString()

			var signing *shared.SystemsV1VerificationConfig
			if bundlesValue.Signing != nil {
				var excludeFiles []string = []string{}
				for _, excludeFilesItem := range bundlesValue.Signing.ExcludeFiles {
					excludeFiles = append(excludeFiles, excludeFilesItem.ValueString())
				}
				keyid := new(string)
				if !bundlesValue.Signing.Keyid.IsUnknown() && !bundlesValue.Signing.Keyid.IsNull() {
					*keyid = bundlesValue.Signing.Keyid.ValueString()
				} else {
					keyid = nil
				}
				publicKeys := make(map[string]shared.SystemsV1KeyConfig)
				for publicKeysKey, publicKeysValue := range bundlesValue.Signing.PublicKeys {
					algorithm := new(string)
					if !publicKeysValue.Algorithm.IsUnknown() && !publicKeysValue.Algorithm.IsNull() {
						*algorithm = publicKeysValue.Algorithm.ValueString()
					} else {
						algorithm = nil
					}
					key1 := new(string)
					if !publicKeysValue.Key.IsUnknown() && !publicKeysValue.Key.IsNull() {
						*key1 = publicKeysValue.Key.ValueString()
					} else {
						key1 = nil
					}
					privateKey := new(string)
					if !publicKeysValue.PrivateKey.IsUnknown() && !publicKeysValue.PrivateKey.IsNull() {
						*privateKey = publicKeysValue.PrivateKey.ValueString()
					} else {
						privateKey = nil
					}
					scope := new(string)
					if !publicKeysValue.Scope.IsUnknown() && !publicKeysValue.Scope.IsNull() {
						*scope = publicKeysValue.Scope.ValueString()
					} else {
						scope = nil
					}
					publicKeysInst := shared.SystemsV1KeyConfig{
						Algorithm:  algorithm,
						Key:        key1,
						PrivateKey: privateKey,
						Scope:      scope,
					}
					publicKeys[publicKeysKey] = publicKeysInst
				}
				scope1 := new(string)
				if !bundlesValue.Signing.Scope.IsUnknown() && !bundlesValue.Signing.Scope.IsNull() {
					*scope1 = bundlesValue.Signing.Scope.ValueString()
				} else {
					scope1 = nil
				}
				signing = &shared.SystemsV1VerificationConfig{
					ExcludeFiles: excludeFiles,
					Keyid:        keyid,
					PublicKeys:   publicKeys,
					Scope:        scope1,
				}
			}
			sizeLimitBytes := new(int64)
			if !bundlesValue.SizeLimitBytes.IsUnknown() && !bundlesValue.SizeLimitBytes.IsNull() {
				*sizeLimitBytes = bundlesValue.SizeLimitBytes.ValueInt64()
			} else {
				sizeLimitBytes = nil
			}
			bundlesInst := shared.SystemsV1OpaConfigBundleDeclaration{
				Persist:        persist,
				Polling:        polling,
				Resource:       resource,
				Service:        service,
				Signing:        signing,
				SizeLimitBytes: sizeLimitBytes,
			}
			bundles[bundlesKey] = bundlesInst
		}
		var services []shared.SystemsV1OpaConfigServiceDeclaration = []shared.SystemsV1OpaConfigServiceDeclaration{}
		for _, servicesItem := range r.ExternalBundles.Services {
			allowInsecureTLS := new(bool)
			if !servicesItem.AllowInsecureTLS.IsUnknown() && !servicesItem.AllowInsecureTLS.IsNull() {
				*allowInsecureTLS = servicesItem.AllowInsecureTLS.ValueBool()
			} else {
				allowInsecureTLS = nil
			}
			var credentials *shared.SystemsV1OpaConfigServiceDeclarationCredentials
			if servicesItem.Credentials != nil {
				var azureManagedIdentity *shared.SystemsV1AzureManagedIdentitiesAuthPlugin
				if servicesItem.Credentials.AzureManagedIdentity != nil {
					var apiVersion string
					apiVersion = servicesItem.Credentials.AzureManagedIdentity.APIVersion.ValueString()

					var clientID string
					clientID = servicesItem.Credentials.AzureManagedIdentity.ClientID.ValueString()

					var endpoint1 string
					endpoint1 = servicesItem.Credentials.AzureManagedIdentity.Endpoint.ValueString()

					var miResID string
					miResID = servicesItem.Credentials.AzureManagedIdentity.MiResID.ValueString()

					var objectID string
					objectID = servicesItem.Credentials.AzureManagedIdentity.ObjectID.ValueString()

					var resource1 string
					resource1 = servicesItem.Credentials.AzureManagedIdentity.Resource.ValueString()

					azureManagedIdentity = &shared.SystemsV1AzureManagedIdentitiesAuthPlugin{
						APIVersion: apiVersion,
						ClientID:   clientID,
						Endpoint:   endpoint1,
						MiResID:    miResID,
						ObjectID:   objectID,
						Resource:   resource1,
					}
				}
				var bearer *shared.SystemsV1BearerAuthPlugin
				if servicesItem.Credentials.Bearer != nil {
					scheme := new(string)
					if !servicesItem.Credentials.Bearer.Scheme.IsUnknown() && !servicesItem.Credentials.Bearer.Scheme.IsNull() {
						*scheme = servicesItem.Credentials.Bearer.Scheme.ValueString()
					} else {
						scheme = nil
					}
					var token string
					token = servicesItem.Credentials.Bearer.Token.ValueString()

					var tokenPath string
					tokenPath = servicesItem.Credentials.Bearer.TokenPath.ValueString()

					bearer = &shared.SystemsV1BearerAuthPlugin{
						Scheme:    scheme,
						Token:     token,
						TokenPath: tokenPath,
					}
				}
				var clientTLS *shared.SystemsV1ClientTLSAuthPlugin
				if servicesItem.Credentials.ClientTLS != nil {
					var cert string
					cert = servicesItem.Credentials.ClientTLS.Cert.ValueString()

					var privateKey1 string
					privateKey1 = servicesItem.Credentials.ClientTLS.PrivateKey.ValueString()

					privateKeyPassphrase := new(string)
					if !servicesItem.Credentials.ClientTLS.PrivateKeyPassphrase.IsUnknown() && !servicesItem.Credentials.ClientTLS.PrivateKeyPassphrase.IsNull() {
						*privateKeyPassphrase = servicesItem.Credentials.ClientTLS.PrivateKeyPassphrase.ValueString()
					} else {
						privateKeyPassphrase = nil
					}
					clientTLS = &shared.SystemsV1ClientTLSAuthPlugin{
						Cert:                 cert,
						PrivateKey:           privateKey1,
						PrivateKeyPassphrase: privateKeyPassphrase,
					}
				}
				var gcpMetadata *shared.SystemsV1GcpMetadataAuthPlugin
				if servicesItem.Credentials.GcpMetadata != nil {
					var accessTokenPath string
					accessTokenPath = servicesItem.Credentials.GcpMetadata.AccessTokenPath.ValueString()

					var audience string
					audience = servicesItem.Credentials.GcpMetadata.Audience.ValueString()

					var endpoint2 string
					endpoint2 = servicesItem.Credentials.GcpMetadata.Endpoint.ValueString()

					var idTokenPath string
					idTokenPath = servicesItem.Credentials.GcpMetadata.IDTokenPath.ValueString()

					var scopes []string = []string{}
					for _, scopesItem := range servicesItem.Credentials.GcpMetadata.Scopes {
						scopes = append(scopes, scopesItem.ValueString())
					}
					gcpMetadata = &shared.SystemsV1GcpMetadataAuthPlugin{
						AccessTokenPath: accessTokenPath,
						Audience:        audience,
						Endpoint:        endpoint2,
						IDTokenPath:     idTokenPath,
						Scopes:          scopes,
					}
				}
				var oauth2 *shared.SystemsV1Oauth2ClientCredentialsAuthPlugin
				if servicesItem.Credentials.Oauth2 != nil {
					additionalClaims := shared.AdditionalClaims{}
					additionalHeaders := make(map[string]string)
					for additionalHeadersKey, additionalHeadersValue := range servicesItem.Credentials.Oauth2.AdditionalHeaders {
						var additionalHeadersInst string
						additionalHeadersInst = additionalHeadersValue.ValueString()

						additionalHeaders[additionalHeadersKey] = additionalHeadersInst
					}
					additionalParameters := make(map[string]string)
					for additionalParametersKey, additionalParametersValue := range servicesItem.Credentials.Oauth2.AdditionalParameters {
						var additionalParametersInst string
						additionalParametersInst = additionalParametersValue.ValueString()

						additionalParameters[additionalParametersKey] = additionalParametersInst
					}
					var clientId1 string
					clientId1 = servicesItem.Credentials.Oauth2.ClientID.ValueString()

					var clientSecret string
					clientSecret = servicesItem.Credentials.Oauth2.ClientSecret.ValueString()

					var grantType string
					grantType = servicesItem.Credentials.Oauth2.GrantType.ValueString()

					var includeJtiClaim bool
					includeJtiClaim = servicesItem.Credentials.Oauth2.IncludeJtiClaim.ValueBool()

					var scopes1 []string = []string{}
					for _, scopesItem1 := range servicesItem.Credentials.Oauth2.Scopes {
						scopes1 = append(scopes1, scopesItem1.ValueString())
					}
					var signingKey string
					signingKey = servicesItem.Credentials.Oauth2.SigningKey.ValueString()

					var thumbprint string
					thumbprint = servicesItem.Credentials.Oauth2.Thumbprint.ValueString()

					var tokenURL string
					tokenURL = servicesItem.Credentials.Oauth2.TokenURL.ValueString()

					oauth2 = &shared.SystemsV1Oauth2ClientCredentialsAuthPlugin{
						AdditionalClaims:     additionalClaims,
						AdditionalHeaders:    additionalHeaders,
						AdditionalParameters: additionalParameters,
						ClientID:             clientId1,
						ClientSecret:         clientSecret,
						GrantType:            grantType,
						IncludeJtiClaim:      includeJtiClaim,
						Scopes:               scopes1,
						SigningKey:           signingKey,
						Thumbprint:           thumbprint,
						TokenURL:             tokenURL,
					}
				}
				plugin := new(string)
				if !servicesItem.Credentials.Plugin.IsUnknown() && !servicesItem.Credentials.Plugin.IsNull() {
					*plugin = servicesItem.Credentials.Plugin.ValueString()
				} else {
					plugin = nil
				}
				var s3Signing *shared.SystemsV1AwsSigningAuthPlugin
				if servicesItem.Credentials.S3Signing != nil {
					var environmentCredentials1 interface{}
					if !servicesItem.Credentials.S3Signing.EnvironmentCredentials.IsUnknown() && !servicesItem.Credentials.S3Signing.EnvironmentCredentials.IsNull() {
						_ = json.Unmarshal([]byte(servicesItem.Credentials.S3Signing.EnvironmentCredentials.ValueString()), &environmentCredentials1)
					}
					var metadataCredentials1 *shared.SystemsV1AwsMetadataCredentialService
					if servicesItem.Credentials.S3Signing.MetadataCredentials != nil {
						var awsRegion2 string
						awsRegion2 = servicesItem.Credentials.S3Signing.MetadataCredentials.AwsRegion.ValueString()

						iamRole1 := new(string)
						if !servicesItem.Credentials.S3Signing.MetadataCredentials.IamRole.IsUnknown() && !servicesItem.Credentials.S3Signing.MetadataCredentials.IamRole.IsNull() {
							*iamRole1 = servicesItem.Credentials.S3Signing.MetadataCredentials.IamRole.ValueString()
						} else {
							iamRole1 = nil
						}
						metadataCredentials1 = &shared.SystemsV1AwsMetadataCredentialService{
							AwsRegion: awsRegion2,
							IamRole:   iamRole1,
						}
					}
					var profileCredentials *shared.SystemsV1AwsProfileCredentialService
					if servicesItem.Credentials.S3Signing.ProfileCredentials != nil {
						var awsRegion3 string
						awsRegion3 = servicesItem.Credentials.S3Signing.ProfileCredentials.AwsRegion.ValueString()

						path3 := new(string)
						if !servicesItem.Credentials.S3Signing.ProfileCredentials.Path.IsUnknown() && !servicesItem.Credentials.S3Signing.ProfileCredentials.Path.IsNull() {
							*path3 = servicesItem.Credentials.S3Signing.ProfileCredentials.Path.ValueString()
						} else {
							path3 = nil
						}
						profile := new(string)
						if !servicesItem.Credentials.S3Signing.ProfileCredentials.Profile.IsUnknown() && !servicesItem.Credentials.S3Signing.ProfileCredentials.Profile.IsNull() {
							*profile = servicesItem.Credentials.S3Signing.ProfileCredentials.Profile.ValueString()
						} else {
							profile = nil
						}
						profileCredentials = &shared.SystemsV1AwsProfileCredentialService{
							AwsRegion: awsRegion3,
							Path:      path3,
							Profile:   profile,
						}
					}
					service1 := new(string)
					if !servicesItem.Credentials.S3Signing.Service.IsUnknown() && !servicesItem.Credentials.S3Signing.Service.IsNull() {
						*service1 = servicesItem.Credentials.S3Signing.Service.ValueString()
					} else {
						service1 = nil
					}
					var webIdentityCredentials1 *shared.SystemsV1AwsWebIdentityCredentialService
					if servicesItem.Credentials.S3Signing.WebIdentityCredentials != nil {
						var awsRegion4 string
						awsRegion4 = servicesItem.Credentials.S3Signing.WebIdentityCredentials.AwsRegion.ValueString()

						var sessionName1 string
						sessionName1 = servicesItem.Credentials.S3Signing.WebIdentityCredentials.SessionName.ValueString()

						webIdentityCredentials1 = &shared.SystemsV1AwsWebIdentityCredentialService{
							AwsRegion:   awsRegion4,
							SessionName: sessionName1,
						}
					}
					s3Signing = &shared.SystemsV1AwsSigningAuthPlugin{
						EnvironmentCredentials: environmentCredentials1,
						MetadataCredentials:    metadataCredentials1,
						ProfileCredentials:     profileCredentials,
						Service:                service1,
						WebIdentityCredentials: webIdentityCredentials1,
					}
				}
				credentials = &shared.SystemsV1OpaConfigServiceDeclarationCredentials{
					AzureManagedIdentity: azureManagedIdentity,
					Bearer:               bearer,
					ClientTLS:            clientTLS,
					GcpMetadata:          gcpMetadata,
					Oauth2:               oauth2,
					Plugin:               plugin,
					S3Signing:            s3Signing,
				}
			}
			headers := make(map[string]string)
			for headersKey, headersValue := range servicesItem.Headers {
				var headersInst string
				headersInst = headersValue.ValueString()

				headers[headersKey] = headersInst
			}
			keys := make(map[string]shared.KeysConfig)
			for keysKey, keysValue := range servicesItem.Keys {
				var algorithm1 string
				algorithm1 = keysValue.Algorithm.ValueString()

				var key2 string
				key2 = keysValue.Key.ValueString()

				var privateKey2 string
				privateKey2 = keysValue.PrivateKey.ValueString()

				var scope2 string
				scope2 = keysValue.Scope.ValueString()

				keysInst := shared.KeysConfig{
					Algorithm:  algorithm1,
					Key:        key2,
					PrivateKey: privateKey2,
					Scope:      scope2,
				}
				keys[keysKey] = keysInst
			}
			var name string
			name = servicesItem.Name.ValueString()

			responseHeaderTimeoutSeconds := new(int64)
			if !servicesItem.ResponseHeaderTimeoutSeconds.IsUnknown() && !servicesItem.ResponseHeaderTimeoutSeconds.IsNull() {
				*responseHeaderTimeoutSeconds = servicesItem.ResponseHeaderTimeoutSeconds.ValueInt64()
			} else {
				responseHeaderTimeoutSeconds = nil
			}
			var tls *shared.SystemsV1ServerTLSConfig
			if servicesItem.TLS != nil {
				caCert := new(string)
				if !servicesItem.TLS.CaCert.IsUnknown() && !servicesItem.TLS.CaCert.IsNull() {
					*caCert = servicesItem.TLS.CaCert.ValueString()
				} else {
					caCert = nil
				}
				systemCaRequired := new(bool)
				if !servicesItem.TLS.SystemCaRequired.IsUnknown() && !servicesItem.TLS.SystemCaRequired.IsNull() {
					*systemCaRequired = servicesItem.TLS.SystemCaRequired.ValueBool()
				} else {
					systemCaRequired = nil
				}
				tls = &shared.SystemsV1ServerTLSConfig{
					CaCert:           caCert,
					SystemCaRequired: systemCaRequired,
				}
			}
			type1 := new(string)
			if !servicesItem.Type.IsUnknown() && !servicesItem.Type.IsNull() {
				*type1 = servicesItem.Type.ValueString()
			} else {
				type1 = nil
			}
			var url string
			url = servicesItem.URL.ValueString()

			services = append(services, shared.SystemsV1OpaConfigServiceDeclaration{
				AllowInsecureTLS:             allowInsecureTLS,
				Credentials:                  credentials,
				Headers:                      headers,
				Keys:                         keys,
				Name:                         name,
				ResponseHeaderTimeoutSeconds: responseHeaderTimeoutSeconds,
				TLS:                          tls,
				Type:                         type1,
				URL:                          url,
			})
		}
		externalBundles = &shared.SystemsV1ExternalBundleConfig{
			Bundles:  bundles,
			Services: services,
		}
	}
	externalID := new(string)
	if !r.ExternalID.IsUnknown() && !r.ExternalID.IsNull() {
		*externalID = r.ExternalID.ValueString()
	} else {
		externalID = nil
	}
	filterStacks := new(bool)
	if !r.FilterStacks.IsUnknown() && !r.FilterStacks.IsNull() {
		*filterStacks = r.FilterStacks.ValueBool()
	} else {
		filterStacks = nil
	}
	kafkaTopic := new(string)
	if !r.KafkaTopic.IsUnknown() && !r.KafkaTopic.IsNull() {
		*kafkaTopic = r.KafkaTopic.ValueString()
	} else {
		kafkaTopic = nil
	}
	mockOpaEnabled := new(bool)
	if !r.MockOpaEnabled.IsUnknown() && !r.MockOpaEnabled.IsNull() {
		*mockOpaEnabled = r.MockOpaEnabled.ValueBool()
	} else {
		mockOpaEnabled = nil
	}
	var name1 string
	name1 = r.Name.ValueString()

	readOnly := new(bool)
	if !r.ReadOnly.IsUnknown() && !r.ReadOnly.IsNull() {
		*readOnly = r.ReadOnly.ValueBool()
	} else {
		readOnly = nil
	}
	var sourceControl *shared.GitV1SourceControlConfig
	if r.SourceControl != nil {
		var commit string
		commit = r.SourceControl.Origin.Commit.ValueString()

		var credentials1 string
		credentials1 = r.SourceControl.Origin.Credentials.ValueString()

		var path4 string
		path4 = r.SourceControl.Origin.Path.ValueString()

		var reference string
		reference = r.SourceControl.Origin.Reference.ValueString()

		var sshCredentials *shared.GitV1SSHCredentials
		if r.SourceControl.Origin.SSHCredentials != nil {
			var passphrase string
			passphrase = r.SourceControl.Origin.SSHCredentials.Passphrase.ValueString()

			var privateKey3 string
			privateKey3 = r.SourceControl.Origin.SSHCredentials.PrivateKey.ValueString()

			sshCredentials = &shared.GitV1SSHCredentials{
				Passphrase: passphrase,
				PrivateKey: privateKey3,
			}
		}
		var url1 string
		url1 = r.SourceControl.Origin.URL.ValueString()

		origin := shared.GitV1GitRepoConfig{
			Commit:         commit,
			Credentials:    credentials1,
			Path:           path4,
			Reference:      reference,
			SSHCredentials: sshCredentials,
			URL:            url1,
		}
		sourceControl = &shared.GitV1SourceControlConfig{
			Origin: origin,
		}
	}
	var typeVar1 string
	typeVar1 = r.Type.ValueString()

	var typeParameters *shared.SystemsV1SystemsPostRequestTypeParameters
	if r.TypeParameters != nil {
		typeParameters = &shared.SystemsV1SystemsPostRequestTypeParameters{}
	}
	out := shared.SystemsV1SystemsPostRequest{
		BundleDownload:        bundleDownload,
		BundleRegistry:        bundleRegistry,
		ContextBundleDataOnly: contextBundleDataOnly,
		ContextBundleRoots:    contextBundleRoots,
		DecisionMappings:      decisionMappings,
		DeploymentParameters:  deploymentParameters,
		Description:           description,
		ErrorSetting:          errorSetting,
		ExternalBundles:       externalBundles,
		ExternalID:            externalID,
		FilterStacks:          filterStacks,
		KafkaTopic:            kafkaTopic,
		MockOpaEnabled:        mockOpaEnabled,
		Name:                  name1,
		ReadOnly:              readOnly,
		SourceControl:         sourceControl,
		Type:                  typeVar1,
		TypeParameters:        typeParameters,
	}
	return &out
}

func (r *SystemResourceModel) RefreshFromSharedSystemsV1SystemConfig(resp *shared.SystemsV1SystemConfig) {
	r.Authz.RoleBindings = []tfTypes.SystemsV1V1RoleBindingConfig{}
	if len(r.Authz.RoleBindings) > len(resp.Authz.RoleBindings) {
		r.Authz.RoleBindings = r.Authz.RoleBindings[:len(resp.Authz.RoleBindings)]
	}
	for roleBindingsCount, roleBindingsItem := range resp.Authz.RoleBindings {
		var roleBindings1 tfTypes.SystemsV1V1RoleBindingConfig
		roleBindings1.ID = types.StringValue(roleBindingsItem.ID)
		roleBindings1.RoleName = types.StringValue(roleBindingsItem.RoleName)
		if roleBindingsCount+1 > len(r.Authz.RoleBindings) {
			r.Authz.RoleBindings = append(r.Authz.RoleBindings, roleBindings1)
		} else {
			r.Authz.RoleBindings[roleBindingsCount].ID = roleBindings1.ID
			r.Authz.RoleBindings[roleBindingsCount].RoleName = roleBindings1.RoleName
		}
	}
	if resp.BundleDownload == nil {
		r.BundleDownload = nil
	} else {
		r.BundleDownload = &tfTypes.SystemsV1BundleDownloadConfig{}
		r.BundleDownload.DeltaBundles = types.BoolPointerValue(resp.BundleDownload.DeltaBundles)
	}
	if resp.BundleRegistry == nil {
		r.BundleRegistry = nil
	} else {
		r.BundleRegistry = &tfTypes.SystemsV1BundleRegistryConfig{}
		r.BundleRegistry.DisableBundleCompatibilityCheck = types.BoolPointerValue(resp.BundleRegistry.DisableBundleCompatibilityCheck)
		if resp.BundleRegistry.DistributionS3 == nil {
			r.BundleRegistry.DistributionS3 = nil
		} else {
			r.BundleRegistry.DistributionS3 = &tfTypes.SystemsV1BundleDistributionS3Config{}
			r.BundleRegistry.DistributionS3.AccessKeys = types.StringPointerValue(resp.BundleRegistry.DistributionS3.AccessKeys)
			r.BundleRegistry.DistributionS3.Bucket = types.StringValue(resp.BundleRegistry.DistributionS3.Bucket)
			r.BundleRegistry.DistributionS3.ContextPath = types.StringPointerValue(resp.BundleRegistry.DistributionS3.ContextPath)
			r.BundleRegistry.DistributionS3.DiscoveryPath = types.StringPointerValue(resp.BundleRegistry.DistributionS3.DiscoveryPath)
			r.BundleRegistry.DistributionS3.Endpoint = types.StringPointerValue(resp.BundleRegistry.DistributionS3.Endpoint)
			if resp.BundleRegistry.DistributionS3.OpaCredentials == nil {
				r.BundleRegistry.DistributionS3.OpaCredentials = nil
			} else {
				r.BundleRegistry.DistributionS3.OpaCredentials = &tfTypes.SystemsV1BundleDistributionS3ConfigOpaCredentials{}
				if resp.BundleRegistry.DistributionS3.OpaCredentials.EnvironmentCredentials == nil {
					r.BundleRegistry.DistributionS3.OpaCredentials.EnvironmentCredentials = nil
				} else {
					r.BundleRegistry.DistributionS3.OpaCredentials.EnvironmentCredentials = &tfTypes.TypeParameters{}
				}
				if resp.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials == nil {
					r.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials = nil
				} else {
					r.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials = &tfTypes.SystemsV1BundleDistributionS3ConfigOpaCredentialsMetadataCredentials{}
					r.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials.AwsRegion = types.StringValue(resp.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials.AwsRegion)
					r.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials.IamRole = types.StringPointerValue(resp.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials.IamRole)
				}
				if resp.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials == nil {
					r.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials = nil
				} else {
					r.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials = &tfTypes.SystemsV1BundleDistributionS3ConfigOpaCredentialsWebIdentityCredentials{}
					r.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials.AwsRegion = types.StringValue(resp.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials.AwsRegion)
					r.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials.SessionName = types.StringValue(resp.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials.SessionName)
				}
			}
			r.BundleRegistry.DistributionS3.PolicyPath = types.StringPointerValue(resp.BundleRegistry.DistributionS3.PolicyPath)
			r.BundleRegistry.DistributionS3.Region = types.StringValue(resp.BundleRegistry.DistributionS3.Region)
			r.BundleRegistry.DistributionS3.RoleArn = types.StringPointerValue(resp.BundleRegistry.DistributionS3.RoleArn)
		}
		r.BundleRegistry.Entrypoints = []types.String{}
		for _, v := range resp.BundleRegistry.Entrypoints {
			r.BundleRegistry.Entrypoints = append(r.BundleRegistry.Entrypoints, types.StringValue(v))
		}
		r.BundleRegistry.ManualDeployment = types.BoolPointerValue(resp.BundleRegistry.ManualDeployment)
		if len(resp.BundleRegistry.ManualDeploymentOverrides) > 0 {
			r.BundleRegistry.ManualDeploymentOverrides = make(map[string]types.Bool)
			for key, value := range resp.BundleRegistry.ManualDeploymentOverrides {
				r.BundleRegistry.ManualDeploymentOverrides[key] = types.BoolValue(value)
			}
		}
		r.BundleRegistry.MaxBundles = types.Int64PointerValue(resp.BundleRegistry.MaxBundles)
		r.BundleRegistry.MaxDeployedBundles = types.Int64PointerValue(resp.BundleRegistry.MaxDeployedBundles)
		if resp.BundleRegistry.OptimizationLevel != nil {
			r.BundleRegistry.OptimizationLevel = types.Int64Value(int64(*resp.BundleRegistry.OptimizationLevel))
		} else {
			r.BundleRegistry.OptimizationLevel = types.Int64Null()
		}
	}
	r.ContextBundleDataOnly = types.BoolPointerValue(resp.ContextBundleDataOnly)
	r.ContextBundleRoots = []types.String{}
	for _, v := range resp.ContextBundleRoots {
		r.ContextBundleRoots = append(r.ContextBundleRoots, types.StringValue(v))
	}
	r.Datasources = []tfTypes.SystemsV1DatasourceConfig{}
	if len(r.Datasources) > len(resp.Datasources) {
		r.Datasources = r.Datasources[:len(resp.Datasources)]
	}
	for datasourcesCount, datasourcesItem := range resp.Datasources {
		var datasources1 tfTypes.SystemsV1DatasourceConfig
		datasources1.Category = types.StringValue(datasourcesItem.Category)
		datasources1.ID = types.StringValue(datasourcesItem.ID)
		datasources1.Optional = types.BoolPointerValue(datasourcesItem.Optional)
		if datasourcesItem.Status == nil {
			datasources1.Status = nil
		} else {
			datasources1.Status = &tfTypes.MetaV1Status{}
			datasources1.Status.Code = types.StringValue(datasourcesItem.Status.Code)
			datasources1.Status.Message = types.StringValue(datasourcesItem.Status.Message)
			datasources1.Status.Timestamp = types.StringValue(datasourcesItem.Status.Timestamp.Format(time.RFC3339Nano))
		}
		if datasourcesCount+1 > len(r.Datasources) {
			r.Datasources = append(r.Datasources, datasources1)
		} else {
			r.Datasources[datasourcesCount].Category = datasources1.Category
			r.Datasources[datasourcesCount].ID = datasources1.ID
			r.Datasources[datasourcesCount].Optional = datasources1.Optional
			r.Datasources[datasourcesCount].Status = datasources1.Status
		}
	}
	if len(resp.DecisionMappings) > 0 {
		r.DecisionMappings = make(map[string]tfTypes.SystemsV1RuleDecisionMappings)
		for systemsV1RuleDecisionMappingsKey, systemsV1RuleDecisionMappingsValue := range resp.DecisionMappings {
			var systemsV1RuleDecisionMappingsResult tfTypes.SystemsV1RuleDecisionMappings
			if systemsV1RuleDecisionMappingsValue.Allowed == nil {
				systemsV1RuleDecisionMappingsResult.Allowed = nil
			} else {
				systemsV1RuleDecisionMappingsResult.Allowed = &tfTypes.SystemsV1AllowedMapping{}
				if systemsV1RuleDecisionMappingsValue.Allowed.Expected == nil {
					systemsV1RuleDecisionMappingsResult.Allowed.Expected = types.StringNull()
				} else {
					expectedResult, _ := json.Marshal(systemsV1RuleDecisionMappingsValue.Allowed.Expected)
					systemsV1RuleDecisionMappingsResult.Allowed.Expected = types.StringValue(string(expectedResult))
				}
				systemsV1RuleDecisionMappingsResult.Allowed.Negated = types.BoolPointerValue(systemsV1RuleDecisionMappingsValue.Allowed.Negated)
				systemsV1RuleDecisionMappingsResult.Allowed.Path = types.StringValue(systemsV1RuleDecisionMappingsValue.Allowed.Path)
			}
			systemsV1RuleDecisionMappingsResult.Columns = []tfTypes.SystemsV1ColumnMapping{}
			for columnsCount, columnsItem := range systemsV1RuleDecisionMappingsValue.Columns {
				var columns1 tfTypes.SystemsV1ColumnMapping
				columns1.Key = types.StringValue(columnsItem.Key)
				columns1.Path = types.StringValue(columnsItem.Path)
				columns1.Type = types.StringPointerValue(columnsItem.Type)
				if columnsCount+1 > len(systemsV1RuleDecisionMappingsResult.Columns) {
					systemsV1RuleDecisionMappingsResult.Columns = append(systemsV1RuleDecisionMappingsResult.Columns, columns1)
				} else {
					systemsV1RuleDecisionMappingsResult.Columns[columnsCount].Key = columns1.Key
					systemsV1RuleDecisionMappingsResult.Columns[columnsCount].Path = columns1.Path
					systemsV1RuleDecisionMappingsResult.Columns[columnsCount].Type = columns1.Type
				}
			}
			if systemsV1RuleDecisionMappingsValue.Reason == nil {
				systemsV1RuleDecisionMappingsResult.Reason = nil
			} else {
				systemsV1RuleDecisionMappingsResult.Reason = &tfTypes.SystemsV1ReasonMapping{}
				systemsV1RuleDecisionMappingsResult.Reason.Path = types.StringValue(systemsV1RuleDecisionMappingsValue.Reason.Path)
			}
			r.DecisionMappings[systemsV1RuleDecisionMappingsKey] = systemsV1RuleDecisionMappingsResult
		}
	}
	if resp.DeploymentParameters == nil {
		r.DeploymentParameters = nil
	} else {
		r.DeploymentParameters = &tfTypes.SystemsV1SystemDeploymentParameters{}
		r.DeploymentParameters.DenyOnOpaFail = types.BoolPointerValue(resp.DeploymentParameters.DenyOnOpaFail)
		if resp.DeploymentParameters.Discovery == nil {
			r.DeploymentParameters.Discovery = nil
		} else {
			r.DeploymentParameters.Discovery = &tfTypes.TypeParameters{}
		}
		if resp.DeploymentParameters.Extra == nil {
			r.DeploymentParameters.Extra = nil
		} else {
			r.DeploymentParameters.Extra = &tfTypes.TypeParameters{}
		}
		r.DeploymentParameters.HTTPProxy = types.StringPointerValue(resp.DeploymentParameters.HTTPProxy)
		r.DeploymentParameters.HTTPSProxy = types.StringPointerValue(resp.DeploymentParameters.HTTPSProxy)
		r.DeploymentParameters.KubernetesVersion = types.StringPointerValue(resp.DeploymentParameters.KubernetesVersion)
		r.DeploymentParameters.MutatingWebhookName = types.StringPointerValue(resp.DeploymentParameters.MutatingWebhookName)
		r.DeploymentParameters.Namespace = types.StringPointerValue(resp.DeploymentParameters.Namespace)
		r.DeploymentParameters.NoProxy = types.StringPointerValue(resp.DeploymentParameters.NoProxy)
		if resp.DeploymentParameters.TimeoutSeconds != nil {
			r.DeploymentParameters.TimeoutSeconds = types.Int64Value(int64(*resp.DeploymentParameters.TimeoutSeconds))
		} else {
			r.DeploymentParameters.TimeoutSeconds = types.Int64Null()
		}
		r.DeploymentParameters.TrustedCaCerts = []types.String{}
		for _, v := range resp.DeploymentParameters.TrustedCaCerts {
			r.DeploymentParameters.TrustedCaCerts = append(r.DeploymentParameters.TrustedCaCerts, types.StringValue(v))
		}
		r.DeploymentParameters.TrustedContainerRegistry = types.StringPointerValue(resp.DeploymentParameters.TrustedContainerRegistry)
	}
	r.Description = types.StringPointerValue(resp.Description)
	r.ErrorSetting = types.StringPointerValue(resp.ErrorSetting)
	if len(resp.Errors) > 0 {
		r.Errors = make(map[string]tfTypes.SystemsV1AgentErrors)
		for systemsV1AgentErrorsKey, systemsV1AgentErrorsValue := range resp.Errors {
			var systemsV1AgentErrorsResult tfTypes.SystemsV1AgentErrors
			systemsV1AgentErrorsResult.Errors = []tfTypes.MetaV1Status{}
			for errorsCount, errorsItem := range systemsV1AgentErrorsValue.Errors {
				var errors2 tfTypes.MetaV1Status
				errors2.Code = types.StringValue(errorsItem.Code)
				errors2.Message = types.StringValue(errorsItem.Message)
				errors2.Timestamp = types.StringValue(errorsItem.Timestamp.Format(time.RFC3339Nano))
				if errorsCount+1 > len(systemsV1AgentErrorsResult.Errors) {
					systemsV1AgentErrorsResult.Errors = append(systemsV1AgentErrorsResult.Errors, errors2)
				} else {
					systemsV1AgentErrorsResult.Errors[errorsCount].Code = errors2.Code
					systemsV1AgentErrorsResult.Errors[errorsCount].Message = errors2.Message
					systemsV1AgentErrorsResult.Errors[errorsCount].Timestamp = errors2.Timestamp
				}
			}
			systemsV1AgentErrorsResult.Waiting = types.BoolValue(systemsV1AgentErrorsValue.Waiting)
			r.Errors[systemsV1AgentErrorsKey] = systemsV1AgentErrorsResult
		}
	}
	if resp.ExternalBundles == nil {
		r.ExternalBundles = nil
	} else {
		r.ExternalBundles = &tfTypes.SystemsV1ExternalBundleConfig{}
		if len(resp.ExternalBundles.Bundles) > 0 {
			r.ExternalBundles.Bundles = make(map[string]tfTypes.SystemsV1OpaConfigBundleDeclaration)
			for systemsV1OpaConfigBundleDeclarationKey, systemsV1OpaConfigBundleDeclarationValue := range resp.ExternalBundles.Bundles {
				var systemsV1OpaConfigBundleDeclarationResult tfTypes.SystemsV1OpaConfigBundleDeclaration
				systemsV1OpaConfigBundleDeclarationResult.Persist = types.BoolPointerValue(systemsV1OpaConfigBundleDeclarationValue.Persist)
				if systemsV1OpaConfigBundleDeclarationValue.Polling == nil {
					systemsV1OpaConfigBundleDeclarationResult.Polling = nil
				} else {
					systemsV1OpaConfigBundleDeclarationResult.Polling = &tfTypes.SystemsV1PollingConfig{}
					systemsV1OpaConfigBundleDeclarationResult.Polling.LongPollingTimeoutSeconds = types.Int64PointerValue(systemsV1OpaConfigBundleDeclarationValue.Polling.LongPollingTimeoutSeconds)
					systemsV1OpaConfigBundleDeclarationResult.Polling.MaxDelaySeconds = types.Int64PointerValue(systemsV1OpaConfigBundleDeclarationValue.Polling.MaxDelaySeconds)
					systemsV1OpaConfigBundleDeclarationResult.Polling.MinDelaySeconds = types.Int64PointerValue(systemsV1OpaConfigBundleDeclarationValue.Polling.MinDelaySeconds)
				}
				systemsV1OpaConfigBundleDeclarationResult.Resource = types.StringPointerValue(systemsV1OpaConfigBundleDeclarationValue.Resource)
				systemsV1OpaConfigBundleDeclarationResult.Service = types.StringValue(systemsV1OpaConfigBundleDeclarationValue.Service)
				if systemsV1OpaConfigBundleDeclarationValue.Signing == nil {
					systemsV1OpaConfigBundleDeclarationResult.Signing = nil
				} else {
					systemsV1OpaConfigBundleDeclarationResult.Signing = &tfTypes.SystemsV1VerificationConfig{}
					systemsV1OpaConfigBundleDeclarationResult.Signing.ExcludeFiles = []types.String{}
					for _, v := range systemsV1OpaConfigBundleDeclarationValue.Signing.ExcludeFiles {
						systemsV1OpaConfigBundleDeclarationResult.Signing.ExcludeFiles = append(systemsV1OpaConfigBundleDeclarationResult.Signing.ExcludeFiles, types.StringValue(v))
					}
					systemsV1OpaConfigBundleDeclarationResult.Signing.Keyid = types.StringPointerValue(systemsV1OpaConfigBundleDeclarationValue.Signing.Keyid)
					if len(systemsV1OpaConfigBundleDeclarationValue.Signing.PublicKeys) > 0 {
						systemsV1OpaConfigBundleDeclarationResult.Signing.PublicKeys = make(map[string]tfTypes.SystemsV1KeyConfig)
						for systemsV1KeyConfigKey, systemsV1KeyConfigValue := range systemsV1OpaConfigBundleDeclarationValue.Signing.PublicKeys {
							var systemsV1KeyConfigResult tfTypes.SystemsV1KeyConfig
							systemsV1KeyConfigResult.Algorithm = types.StringPointerValue(systemsV1KeyConfigValue.Algorithm)
							systemsV1KeyConfigResult.Key = types.StringPointerValue(systemsV1KeyConfigValue.Key)
							systemsV1KeyConfigResult.PrivateKey = types.StringPointerValue(systemsV1KeyConfigValue.PrivateKey)
							systemsV1KeyConfigResult.Scope = types.StringPointerValue(systemsV1KeyConfigValue.Scope)
							systemsV1OpaConfigBundleDeclarationResult.Signing.PublicKeys[systemsV1KeyConfigKey] = systemsV1KeyConfigResult
						}
					}
					systemsV1OpaConfigBundleDeclarationResult.Signing.Scope = types.StringPointerValue(systemsV1OpaConfigBundleDeclarationValue.Signing.Scope)
				}
				systemsV1OpaConfigBundleDeclarationResult.SizeLimitBytes = types.Int64PointerValue(systemsV1OpaConfigBundleDeclarationValue.SizeLimitBytes)
				r.ExternalBundles.Bundles[systemsV1OpaConfigBundleDeclarationKey] = systemsV1OpaConfigBundleDeclarationResult
			}
		}
		r.ExternalBundles.Services = []tfTypes.SystemsV1OpaConfigServiceDeclaration{}
		if len(r.ExternalBundles.Services) > len(resp.ExternalBundles.Services) {
			r.ExternalBundles.Services = r.ExternalBundles.Services[:len(resp.ExternalBundles.Services)]
		}
		for servicesCount, servicesItem := range resp.ExternalBundles.Services {
			var services1 tfTypes.SystemsV1OpaConfigServiceDeclaration
			services1.AllowInsecureTLS = types.BoolPointerValue(servicesItem.AllowInsecureTLS)
			if servicesItem.Credentials == nil {
				services1.Credentials = nil
			} else {
				services1.Credentials = &tfTypes.SystemsV1OpaConfigServiceDeclarationCredentials{}
				if servicesItem.Credentials.AzureManagedIdentity == nil {
					services1.Credentials.AzureManagedIdentity = nil
				} else {
					services1.Credentials.AzureManagedIdentity = &tfTypes.SystemsV1AzureManagedIdentitiesAuthPlugin{}
					services1.Credentials.AzureManagedIdentity.APIVersion = types.StringValue(servicesItem.Credentials.AzureManagedIdentity.APIVersion)
					services1.Credentials.AzureManagedIdentity.ClientID = types.StringValue(servicesItem.Credentials.AzureManagedIdentity.ClientID)
					services1.Credentials.AzureManagedIdentity.Endpoint = types.StringValue(servicesItem.Credentials.AzureManagedIdentity.Endpoint)
					services1.Credentials.AzureManagedIdentity.MiResID = types.StringValue(servicesItem.Credentials.AzureManagedIdentity.MiResID)
					services1.Credentials.AzureManagedIdentity.ObjectID = types.StringValue(servicesItem.Credentials.AzureManagedIdentity.ObjectID)
					services1.Credentials.AzureManagedIdentity.Resource = types.StringValue(servicesItem.Credentials.AzureManagedIdentity.Resource)
				}
				if servicesItem.Credentials.Bearer == nil {
					services1.Credentials.Bearer = nil
				} else {
					services1.Credentials.Bearer = &tfTypes.SystemsV1BearerAuthPlugin{}
					services1.Credentials.Bearer.Scheme = types.StringPointerValue(servicesItem.Credentials.Bearer.Scheme)
					services1.Credentials.Bearer.Token = types.StringValue(servicesItem.Credentials.Bearer.Token)
					services1.Credentials.Bearer.TokenPath = types.StringValue(servicesItem.Credentials.Bearer.TokenPath)
				}
				if servicesItem.Credentials.ClientTLS == nil {
					services1.Credentials.ClientTLS = nil
				} else {
					services1.Credentials.ClientTLS = &tfTypes.SystemsV1ClientTLSAuthPlugin{}
					services1.Credentials.ClientTLS.Cert = types.StringValue(servicesItem.Credentials.ClientTLS.Cert)
					services1.Credentials.ClientTLS.PrivateKey = types.StringValue(servicesItem.Credentials.ClientTLS.PrivateKey)
					services1.Credentials.ClientTLS.PrivateKeyPassphrase = types.StringPointerValue(servicesItem.Credentials.ClientTLS.PrivateKeyPassphrase)
				}
				if servicesItem.Credentials.GcpMetadata == nil {
					services1.Credentials.GcpMetadata = nil
				} else {
					services1.Credentials.GcpMetadata = &tfTypes.SystemsV1GcpMetadataAuthPlugin{}
					services1.Credentials.GcpMetadata.AccessTokenPath = types.StringValue(servicesItem.Credentials.GcpMetadata.AccessTokenPath)
					services1.Credentials.GcpMetadata.Audience = types.StringValue(servicesItem.Credentials.GcpMetadata.Audience)
					services1.Credentials.GcpMetadata.Endpoint = types.StringValue(servicesItem.Credentials.GcpMetadata.Endpoint)
					services1.Credentials.GcpMetadata.IDTokenPath = types.StringValue(servicesItem.Credentials.GcpMetadata.IDTokenPath)
					services1.Credentials.GcpMetadata.Scopes = []types.String{}
					for _, v := range servicesItem.Credentials.GcpMetadata.Scopes {
						services1.Credentials.GcpMetadata.Scopes = append(services1.Credentials.GcpMetadata.Scopes, types.StringValue(v))
					}
				}
				if servicesItem.Credentials.Oauth2 == nil {
					services1.Credentials.Oauth2 = nil
				} else {
					services1.Credentials.Oauth2 = &tfTypes.SystemsV1Oauth2ClientCredentialsAuthPlugin{}
					if len(servicesItem.Credentials.Oauth2.AdditionalHeaders) > 0 {
						services1.Credentials.Oauth2.AdditionalHeaders = make(map[string]types.String)
						for key3, value1 := range servicesItem.Credentials.Oauth2.AdditionalHeaders {
							services1.Credentials.Oauth2.AdditionalHeaders[key3] = types.StringValue(value1)
						}
					}
					if len(servicesItem.Credentials.Oauth2.AdditionalParameters) > 0 {
						services1.Credentials.Oauth2.AdditionalParameters = make(map[string]types.String)
						for key4, value2 := range servicesItem.Credentials.Oauth2.AdditionalParameters {
							services1.Credentials.Oauth2.AdditionalParameters[key4] = types.StringValue(value2)
						}
					}
					services1.Credentials.Oauth2.ClientID = types.StringValue(servicesItem.Credentials.Oauth2.ClientID)
					services1.Credentials.Oauth2.ClientSecret = types.StringValue(servicesItem.Credentials.Oauth2.ClientSecret)
					services1.Credentials.Oauth2.GrantType = types.StringValue(servicesItem.Credentials.Oauth2.GrantType)
					services1.Credentials.Oauth2.IncludeJtiClaim = types.BoolValue(servicesItem.Credentials.Oauth2.IncludeJtiClaim)
					services1.Credentials.Oauth2.Scopes = []types.String{}
					for _, v := range servicesItem.Credentials.Oauth2.Scopes {
						services1.Credentials.Oauth2.Scopes = append(services1.Credentials.Oauth2.Scopes, types.StringValue(v))
					}
					services1.Credentials.Oauth2.SigningKey = types.StringValue(servicesItem.Credentials.Oauth2.SigningKey)
					services1.Credentials.Oauth2.Thumbprint = types.StringValue(servicesItem.Credentials.Oauth2.Thumbprint)
					services1.Credentials.Oauth2.TokenURL = types.StringValue(servicesItem.Credentials.Oauth2.TokenURL)
				}
				services1.Credentials.Plugin = types.StringPointerValue(servicesItem.Credentials.Plugin)
				if servicesItem.Credentials.S3Signing == nil {
					services1.Credentials.S3Signing = nil
				} else {
					services1.Credentials.S3Signing = &tfTypes.SystemsV1AwsSigningAuthPlugin{}
					if servicesItem.Credentials.S3Signing.EnvironmentCredentials == nil {
						services1.Credentials.S3Signing.EnvironmentCredentials = types.StringNull()
					} else {
						environmentCredentialsResult, _ := json.Marshal(servicesItem.Credentials.S3Signing.EnvironmentCredentials)
						services1.Credentials.S3Signing.EnvironmentCredentials = types.StringValue(string(environmentCredentialsResult))
					}
					if servicesItem.Credentials.S3Signing.MetadataCredentials == nil {
						services1.Credentials.S3Signing.MetadataCredentials = nil
					} else {
						services1.Credentials.S3Signing.MetadataCredentials = &tfTypes.SystemsV1BundleDistributionS3ConfigOpaCredentialsMetadataCredentials{}
						services1.Credentials.S3Signing.MetadataCredentials.AwsRegion = types.StringValue(servicesItem.Credentials.S3Signing.MetadataCredentials.AwsRegion)
						services1.Credentials.S3Signing.MetadataCredentials.IamRole = types.StringPointerValue(servicesItem.Credentials.S3Signing.MetadataCredentials.IamRole)
					}
					if servicesItem.Credentials.S3Signing.ProfileCredentials == nil {
						services1.Credentials.S3Signing.ProfileCredentials = nil
					} else {
						services1.Credentials.S3Signing.ProfileCredentials = &tfTypes.SystemsV1AwsProfileCredentialService{}
						services1.Credentials.S3Signing.ProfileCredentials.AwsRegion = types.StringValue(servicesItem.Credentials.S3Signing.ProfileCredentials.AwsRegion)
						services1.Credentials.S3Signing.ProfileCredentials.Path = types.StringPointerValue(servicesItem.Credentials.S3Signing.ProfileCredentials.Path)
						services1.Credentials.S3Signing.ProfileCredentials.Profile = types.StringPointerValue(servicesItem.Credentials.S3Signing.ProfileCredentials.Profile)
					}
					services1.Credentials.S3Signing.Service = types.StringPointerValue(servicesItem.Credentials.S3Signing.Service)
					if servicesItem.Credentials.S3Signing.WebIdentityCredentials == nil {
						services1.Credentials.S3Signing.WebIdentityCredentials = nil
					} else {
						services1.Credentials.S3Signing.WebIdentityCredentials = &tfTypes.SystemsV1BundleDistributionS3ConfigOpaCredentialsWebIdentityCredentials{}
						services1.Credentials.S3Signing.WebIdentityCredentials.AwsRegion = types.StringValue(servicesItem.Credentials.S3Signing.WebIdentityCredentials.AwsRegion)
						services1.Credentials.S3Signing.WebIdentityCredentials.SessionName = types.StringValue(servicesItem.Credentials.S3Signing.WebIdentityCredentials.SessionName)
					}
				}
			}
			if len(servicesItem.Headers) > 0 {
				services1.Headers = make(map[string]types.String)
				for key5, value3 := range servicesItem.Headers {
					services1.Headers[key5] = types.StringValue(value3)
				}
			}
			if len(servicesItem.Keys) > 0 {
				services1.Keys = make(map[string]tfTypes.KeysConfig)
				for keysConfigKey, keysConfigValue := range servicesItem.Keys {
					var keysConfigResult tfTypes.KeysConfig
					keysConfigResult.Algorithm = types.StringValue(keysConfigValue.Algorithm)
					keysConfigResult.Key = types.StringValue(keysConfigValue.Key)
					keysConfigResult.PrivateKey = types.StringValue(keysConfigValue.PrivateKey)
					keysConfigResult.Scope = types.StringValue(keysConfigValue.Scope)
					services1.Keys[keysConfigKey] = keysConfigResult
				}
			}
			services1.Name = types.StringValue(servicesItem.Name)
			services1.ResponseHeaderTimeoutSeconds = types.Int64PointerValue(servicesItem.ResponseHeaderTimeoutSeconds)
			if servicesItem.TLS == nil {
				services1.TLS = nil
			} else {
				services1.TLS = &tfTypes.SystemsV1ServerTLSConfig{}
				services1.TLS.CaCert = types.StringPointerValue(servicesItem.TLS.CaCert)
				services1.TLS.SystemCaRequired = types.BoolPointerValue(servicesItem.TLS.SystemCaRequired)
			}
			services1.Type = types.StringPointerValue(servicesItem.Type)
			services1.URL = types.StringValue(servicesItem.URL)
			if servicesCount+1 > len(r.ExternalBundles.Services) {
				r.ExternalBundles.Services = append(r.ExternalBundles.Services, services1)
			} else {
				r.ExternalBundles.Services[servicesCount].AllowInsecureTLS = services1.AllowInsecureTLS
				r.ExternalBundles.Services[servicesCount].Credentials = services1.Credentials
				r.ExternalBundles.Services[servicesCount].Headers = services1.Headers
				r.ExternalBundles.Services[servicesCount].Keys = services1.Keys
				r.ExternalBundles.Services[servicesCount].Name = services1.Name
				r.ExternalBundles.Services[servicesCount].ResponseHeaderTimeoutSeconds = services1.ResponseHeaderTimeoutSeconds
				r.ExternalBundles.Services[servicesCount].TLS = services1.TLS
				r.ExternalBundles.Services[servicesCount].Type = services1.Type
				r.ExternalBundles.Services[servicesCount].URL = services1.URL
			}
		}
	}
	r.ExternalID = types.StringPointerValue(resp.ExternalID)
	r.FilterStacks = types.BoolPointerValue(resp.FilterStacks)
	r.ID = types.StringValue(resp.ID)
	r.KafkaTopic = types.StringPointerValue(resp.KafkaTopic)
	r.MatchingStacks = []types.String{}
	for _, v := range resp.MatchingStacks {
		r.MatchingStacks = append(r.MatchingStacks, types.StringValue(v))
	}
	if resp.Metadata.CreatedAt != nil {
		r.Metadata.CreatedAt = types.StringValue(resp.Metadata.CreatedAt.Format(time.RFC3339Nano))
	} else {
		r.Metadata.CreatedAt = types.StringNull()
	}
	r.Metadata.CreatedBy = types.StringPointerValue(resp.Metadata.CreatedBy)
	r.Metadata.CreatedThrough = types.StringPointerValue(resp.Metadata.CreatedThrough)
	if resp.Metadata.LastModifiedAt != nil {
		r.Metadata.LastModifiedAt = types.StringValue(resp.Metadata.LastModifiedAt.Format(time.RFC3339Nano))
	} else {
		r.Metadata.LastModifiedAt = types.StringNull()
	}
	r.Metadata.LastModifiedBy = types.StringPointerValue(resp.Metadata.LastModifiedBy)
	r.Metadata.LastModifiedThrough = types.StringPointerValue(resp.Metadata.LastModifiedThrough)
	r.MigrationHistory = []tfTypes.SystemsV1MigrationRecord{}
	if len(r.MigrationHistory) > len(resp.MigrationHistory) {
		r.MigrationHistory = r.MigrationHistory[:len(resp.MigrationHistory)]
	}
	for migrationHistoryCount, migrationHistoryItem := range resp.MigrationHistory {
		var migrationHistory1 tfTypes.SystemsV1MigrationRecord
		migrationHistory1.From = types.StringValue(migrationHistoryItem.From)
		migrationHistory1.InitiatedBy = types.StringValue(migrationHistoryItem.InitiatedBy)
		migrationHistory1.InitiatingUser = types.StringValue(migrationHistoryItem.InitiatingUser)
		migrationHistory1.MigratedAt = types.StringValue(migrationHistoryItem.MigratedAt.Format(time.RFC3339Nano))
		migrationHistory1.Recovered = types.BoolPointerValue(migrationHistoryItem.Recovered)
		migrationHistory1.To = types.StringValue(migrationHistoryItem.To)
		if migrationHistoryCount+1 > len(r.MigrationHistory) {
			r.MigrationHistory = append(r.MigrationHistory, migrationHistory1)
		} else {
			r.MigrationHistory[migrationHistoryCount].From = migrationHistory1.From
			r.MigrationHistory[migrationHistoryCount].InitiatedBy = migrationHistory1.InitiatedBy
			r.MigrationHistory[migrationHistoryCount].InitiatingUser = migrationHistory1.InitiatingUser
			r.MigrationHistory[migrationHistoryCount].MigratedAt = migrationHistory1.MigratedAt
			r.MigrationHistory[migrationHistoryCount].Recovered = migrationHistory1.Recovered
			r.MigrationHistory[migrationHistoryCount].To = migrationHistory1.To
		}
	}
	r.MinimumOpaVersion = types.StringPointerValue(resp.MinimumOpaVersion)
	r.MockOpaEnabled = types.BoolPointerValue(resp.MockOpaEnabled)
	r.Name = types.StringValue(resp.Name)
	r.Policies = []tfTypes.SystemsV1PolicyConfig{}
	if len(r.Policies) > len(resp.Policies) {
		r.Policies = r.Policies[:len(resp.Policies)]
	}
	for policiesCount, policiesItem := range resp.Policies {
		var policies1 tfTypes.SystemsV1PolicyConfig
		policies1.Created = types.StringPointerValue(policiesItem.Created)
		policies1.Enforcement.Enforced = types.BoolValue(policiesItem.Enforcement.Enforced)
		policies1.Enforcement.Type = types.StringValue(policiesItem.Enforcement.Type)
		policies1.ID = types.StringValue(policiesItem.ID)
		policies1.Modules = []tfTypes.SystemsV1Module{}
		for modulesCount, modulesItem := range policiesItem.Modules {
			var modules1 tfTypes.SystemsV1Module
			modules1.Name = types.StringValue(modulesItem.Name)
			modules1.Placeholder = types.BoolPointerValue(modulesItem.Placeholder)
			modules1.ReadOnly = types.BoolValue(modulesItem.ReadOnly)
			if modulesItem.Rules == nil {
				modules1.Rules = nil
			} else {
				modules1.Rules = &tfTypes.PoliciesV1RuleCounts{}
				modules1.Rules.Allow = types.Int64Value(int64(modulesItem.Rules.Allow))
				modules1.Rules.Deny = types.Int64Value(int64(modulesItem.Rules.Deny))
				modules1.Rules.Enforce = types.Int64Value(int64(modulesItem.Rules.Enforce))
				modules1.Rules.Ignore = types.Int64Value(int64(modulesItem.Rules.Ignore))
				modules1.Rules.Monitor = types.Int64Value(int64(modulesItem.Rules.Monitor))
				modules1.Rules.Notify = types.Int64Value(int64(modulesItem.Rules.Notify))
				modules1.Rules.Other = types.Int64Value(int64(modulesItem.Rules.Other))
				modules1.Rules.Test = types.Int64Value(int64(modulesItem.Rules.Test))
				modules1.Rules.Total = types.Int64Value(int64(modulesItem.Rules.Total))
			}
			if modulesCount+1 > len(policies1.Modules) {
				policies1.Modules = append(policies1.Modules, modules1)
			} else {
				policies1.Modules[modulesCount].Name = modules1.Name
				policies1.Modules[modulesCount].Placeholder = modules1.Placeholder
				policies1.Modules[modulesCount].ReadOnly = modules1.ReadOnly
				policies1.Modules[modulesCount].Rules = modules1.Rules
			}
		}
		if policiesItem.Rules == nil {
			policies1.Rules = nil
		} else {
			policies1.Rules = &tfTypes.PoliciesV1RuleCounts{}
			policies1.Rules.Allow = types.Int64Value(int64(policiesItem.Rules.Allow))
			policies1.Rules.Deny = types.Int64Value(int64(policiesItem.Rules.Deny))
			policies1.Rules.Enforce = types.Int64Value(int64(policiesItem.Rules.Enforce))
			policies1.Rules.Ignore = types.Int64Value(int64(policiesItem.Rules.Ignore))
			policies1.Rules.Monitor = types.Int64Value(int64(policiesItem.Rules.Monitor))
			policies1.Rules.Notify = types.Int64Value(int64(policiesItem.Rules.Notify))
			policies1.Rules.Other = types.Int64Value(int64(policiesItem.Rules.Other))
			policies1.Rules.Test = types.Int64Value(int64(policiesItem.Rules.Test))
			policies1.Rules.Total = types.Int64Value(int64(policiesItem.Rules.Total))
		}
		policies1.Type = types.StringValue(policiesItem.Type)
		if policiesCount+1 > len(r.Policies) {
			r.Policies = append(r.Policies, policies1)
		} else {
			r.Policies[policiesCount].Created = policies1.Created
			r.Policies[policiesCount].Enforcement = policies1.Enforcement
			r.Policies[policiesCount].ID = policies1.ID
			r.Policies[policiesCount].Modules = policies1.Modules
			r.Policies[policiesCount].Rules = policies1.Rules
			r.Policies[policiesCount].Type = policies1.Type
		}
	}
	r.ReadOnly = types.BoolPointerValue(resp.ReadOnly)
	if resp.SourceControl == nil {
		r.SourceControl = nil
	} else {
		r.SourceControl = &tfTypes.GitV1SourceControlConfig{}
		r.SourceControl.Origin.Commit = types.StringValue(resp.SourceControl.Origin.Commit)
		r.SourceControl.Origin.Credentials = types.StringValue(resp.SourceControl.Origin.Credentials)
		r.SourceControl.Origin.Path = types.StringValue(resp.SourceControl.Origin.Path)
		r.SourceControl.Origin.Reference = types.StringValue(resp.SourceControl.Origin.Reference)
		if resp.SourceControl.Origin.SSHCredentials == nil {
			r.SourceControl.Origin.SSHCredentials = nil
		} else {
			r.SourceControl.Origin.SSHCredentials = &tfTypes.GitV1SSHCredentials{}
			r.SourceControl.Origin.SSHCredentials.Passphrase = types.StringValue(resp.SourceControl.Origin.SSHCredentials.Passphrase)
			r.SourceControl.Origin.SSHCredentials.PrivateKey = types.StringValue(resp.SourceControl.Origin.SSHCredentials.PrivateKey)
		}
		r.SourceControl.Origin.URL = types.StringValue(resp.SourceControl.Origin.URL)
	}
	r.Status = types.StringValue(resp.Status)
	r.Tokens = []tfTypes.TokensV1Token{}
	if len(r.Tokens) > len(resp.Tokens) {
		r.Tokens = r.Tokens[:len(resp.Tokens)]
	}
	for tokensCount, tokensItem := range resp.Tokens {
		var tokens1 tfTypes.TokensV1Token
		tokens1.AllowPathPatterns = []types.String{}
		for _, v := range tokensItem.AllowPathPatterns {
			tokens1.AllowPathPatterns = append(tokens1.AllowPathPatterns, types.StringValue(v))
		}
		tokens1.Description = types.StringValue(tokensItem.Description)
		if tokensItem.Expires != nil {
			tokens1.Expires = types.StringValue(tokensItem.Expires.Format(time.RFC3339Nano))
		} else {
			tokens1.Expires = types.StringNull()
		}
		tokens1.ID = types.StringValue(tokensItem.ID)
		if tokensItem.Metadata.CreatedAt != nil {
			tokens1.Metadata.CreatedAt = types.StringValue(tokensItem.Metadata.CreatedAt.Format(time.RFC3339Nano))
		} else {
			tokens1.Metadata.CreatedAt = types.StringNull()
		}
		tokens1.Metadata.CreatedBy = types.StringPointerValue(tokensItem.Metadata.CreatedBy)
		tokens1.Metadata.CreatedThrough = types.StringPointerValue(tokensItem.Metadata.CreatedThrough)
		if tokensItem.Metadata.LastModifiedAt != nil {
			tokens1.Metadata.LastModifiedAt = types.StringValue(tokensItem.Metadata.LastModifiedAt.Format(time.RFC3339Nano))
		} else {
			tokens1.Metadata.LastModifiedAt = types.StringNull()
		}
		tokens1.Metadata.LastModifiedBy = types.StringPointerValue(tokensItem.Metadata.LastModifiedBy)
		tokens1.Metadata.LastModifiedThrough = types.StringPointerValue(tokensItem.Metadata.LastModifiedThrough)
		tokens1.Token = types.StringPointerValue(tokensItem.Token)
		tokens1.TTL = types.StringValue(tokensItem.TTL)
		tokens1.Uses = types.Int64PointerValue(tokensItem.Uses)
		if tokensCount+1 > len(r.Tokens) {
			r.Tokens = append(r.Tokens, tokens1)
		} else {
			r.Tokens[tokensCount].AllowPathPatterns = tokens1.AllowPathPatterns
			r.Tokens[tokensCount].Description = tokens1.Description
			r.Tokens[tokensCount].Expires = tokens1.Expires
			r.Tokens[tokensCount].ID = tokens1.ID
			r.Tokens[tokensCount].Metadata = tokens1.Metadata
			r.Tokens[tokensCount].Token = tokens1.Token
			r.Tokens[tokensCount].TTL = tokens1.TTL
			r.Tokens[tokensCount].Uses = tokens1.Uses
		}
	}
	r.Type = types.StringValue(resp.Type)
	if resp.TypeParameters == nil {
		r.TypeParameters = nil
	} else {
		r.TypeParameters = &tfTypes.TypeParameters{}
	}
	if len(resp.Uninstall) > 0 {
		r.Uninstall = make(map[string]types.String)
		for key7, value4 := range resp.Uninstall {
			r.Uninstall[key7] = types.StringValue(value4)
		}
	}
}

func (r *SystemResourceModel) RefreshFromSharedSystemsV1SystemsGetResponse(resp *shared.SystemsV1SystemsGetResponse) {
	if resp != nil {
		r.RequestID = types.StringPointerValue(resp.RequestID)
		r.Result.Authz.RoleBindings = []tfTypes.SystemsV1V1RoleBindingConfig{}
		if len(r.Result.Authz.RoleBindings) > len(resp.Result.Authz.RoleBindings) {
			r.Result.Authz.RoleBindings = r.Result.Authz.RoleBindings[:len(resp.Result.Authz.RoleBindings)]
		}
		for roleBindingsCount, roleBindingsItem := range resp.Result.Authz.RoleBindings {
			var roleBindings1 tfTypes.SystemsV1V1RoleBindingConfig
			roleBindings1.ID = types.StringValue(roleBindingsItem.ID)
			roleBindings1.RoleName = types.StringValue(roleBindingsItem.RoleName)
			if roleBindingsCount+1 > len(r.Result.Authz.RoleBindings) {
				r.Result.Authz.RoleBindings = append(r.Result.Authz.RoleBindings, roleBindings1)
			} else {
				r.Result.Authz.RoleBindings[roleBindingsCount].ID = roleBindings1.ID
				r.Result.Authz.RoleBindings[roleBindingsCount].RoleName = roleBindings1.RoleName
			}
		}
		if resp.Result.BundleDownload == nil {
			r.Result.BundleDownload = nil
		} else {
			r.Result.BundleDownload = &tfTypes.SystemsV1BundleDownloadConfig{}
			r.Result.BundleDownload.DeltaBundles = types.BoolPointerValue(resp.Result.BundleDownload.DeltaBundles)
		}
		if resp.Result.BundleRegistry == nil {
			r.Result.BundleRegistry = nil
		} else {
			r.Result.BundleRegistry = &tfTypes.SystemsV1BundleRegistryConfig{}
			r.Result.BundleRegistry.DisableBundleCompatibilityCheck = types.BoolPointerValue(resp.Result.BundleRegistry.DisableBundleCompatibilityCheck)
			if resp.Result.BundleRegistry.DistributionS3 == nil {
				r.Result.BundleRegistry.DistributionS3 = nil
			} else {
				r.Result.BundleRegistry.DistributionS3 = &tfTypes.SystemsV1BundleDistributionS3Config{}
				r.Result.BundleRegistry.DistributionS3.AccessKeys = types.StringPointerValue(resp.Result.BundleRegistry.DistributionS3.AccessKeys)
				r.Result.BundleRegistry.DistributionS3.Bucket = types.StringValue(resp.Result.BundleRegistry.DistributionS3.Bucket)
				r.Result.BundleRegistry.DistributionS3.ContextPath = types.StringPointerValue(resp.Result.BundleRegistry.DistributionS3.ContextPath)
				r.Result.BundleRegistry.DistributionS3.DiscoveryPath = types.StringPointerValue(resp.Result.BundleRegistry.DistributionS3.DiscoveryPath)
				r.Result.BundleRegistry.DistributionS3.Endpoint = types.StringPointerValue(resp.Result.BundleRegistry.DistributionS3.Endpoint)
				if resp.Result.BundleRegistry.DistributionS3.OpaCredentials == nil {
					r.Result.BundleRegistry.DistributionS3.OpaCredentials = nil
				} else {
					r.Result.BundleRegistry.DistributionS3.OpaCredentials = &tfTypes.SystemsV1BundleDistributionS3ConfigOpaCredentials{}
					if resp.Result.BundleRegistry.DistributionS3.OpaCredentials.EnvironmentCredentials == nil {
						r.Result.BundleRegistry.DistributionS3.OpaCredentials.EnvironmentCredentials = nil
					} else {
						r.Result.BundleRegistry.DistributionS3.OpaCredentials.EnvironmentCredentials = &tfTypes.TypeParameters{}
					}
					if resp.Result.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials == nil {
						r.Result.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials = nil
					} else {
						r.Result.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials = &tfTypes.SystemsV1BundleDistributionS3ConfigOpaCredentialsMetadataCredentials{}
						r.Result.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials.AwsRegion = types.StringValue(resp.Result.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials.AwsRegion)
						r.Result.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials.IamRole = types.StringPointerValue(resp.Result.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials.IamRole)
					}
					if resp.Result.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials == nil {
						r.Result.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials = nil
					} else {
						r.Result.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials = &tfTypes.SystemsV1BundleDistributionS3ConfigOpaCredentialsWebIdentityCredentials{}
						r.Result.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials.AwsRegion = types.StringValue(resp.Result.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials.AwsRegion)
						r.Result.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials.SessionName = types.StringValue(resp.Result.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials.SessionName)
					}
				}
				r.Result.BundleRegistry.DistributionS3.PolicyPath = types.StringPointerValue(resp.Result.BundleRegistry.DistributionS3.PolicyPath)
				r.Result.BundleRegistry.DistributionS3.Region = types.StringValue(resp.Result.BundleRegistry.DistributionS3.Region)
				r.Result.BundleRegistry.DistributionS3.RoleArn = types.StringPointerValue(resp.Result.BundleRegistry.DistributionS3.RoleArn)
			}
			r.Result.BundleRegistry.Entrypoints = []types.String{}
			for _, v := range resp.Result.BundleRegistry.Entrypoints {
				r.Result.BundleRegistry.Entrypoints = append(r.Result.BundleRegistry.Entrypoints, types.StringValue(v))
			}
			r.Result.BundleRegistry.ManualDeployment = types.BoolPointerValue(resp.Result.BundleRegistry.ManualDeployment)
			if len(resp.Result.BundleRegistry.ManualDeploymentOverrides) > 0 {
				r.Result.BundleRegistry.ManualDeploymentOverrides = make(map[string]types.Bool)
				for key, value := range resp.Result.BundleRegistry.ManualDeploymentOverrides {
					r.Result.BundleRegistry.ManualDeploymentOverrides[key] = types.BoolValue(value)
				}
			}
			r.Result.BundleRegistry.MaxBundles = types.Int64PointerValue(resp.Result.BundleRegistry.MaxBundles)
			r.Result.BundleRegistry.MaxDeployedBundles = types.Int64PointerValue(resp.Result.BundleRegistry.MaxDeployedBundles)
			if resp.Result.BundleRegistry.OptimizationLevel != nil {
				r.Result.BundleRegistry.OptimizationLevel = types.Int64Value(int64(*resp.Result.BundleRegistry.OptimizationLevel))
			} else {
				r.Result.BundleRegistry.OptimizationLevel = types.Int64Null()
			}
		}
		r.Result.ContextBundleDataOnly = types.BoolPointerValue(resp.Result.ContextBundleDataOnly)
		r.Result.ContextBundleRoots = []types.String{}
		for _, v := range resp.Result.ContextBundleRoots {
			r.Result.ContextBundleRoots = append(r.Result.ContextBundleRoots, types.StringValue(v))
		}
		r.Result.Datasources = []tfTypes.SystemsV1DatasourceConfig{}
		if len(r.Result.Datasources) > len(resp.Result.Datasources) {
			r.Result.Datasources = r.Result.Datasources[:len(resp.Result.Datasources)]
		}
		for datasourcesCount, datasourcesItem := range resp.Result.Datasources {
			var datasources1 tfTypes.SystemsV1DatasourceConfig
			datasources1.Category = types.StringValue(datasourcesItem.Category)
			datasources1.ID = types.StringValue(datasourcesItem.ID)
			datasources1.Optional = types.BoolPointerValue(datasourcesItem.Optional)
			if datasourcesItem.Status == nil {
				datasources1.Status = nil
			} else {
				datasources1.Status = &tfTypes.MetaV1Status{}
				datasources1.Status.Code = types.StringValue(datasourcesItem.Status.Code)
				datasources1.Status.Message = types.StringValue(datasourcesItem.Status.Message)
				datasources1.Status.Timestamp = types.StringValue(datasourcesItem.Status.Timestamp.Format(time.RFC3339Nano))
			}
			if datasourcesCount+1 > len(r.Result.Datasources) {
				r.Result.Datasources = append(r.Result.Datasources, datasources1)
			} else {
				r.Result.Datasources[datasourcesCount].Category = datasources1.Category
				r.Result.Datasources[datasourcesCount].ID = datasources1.ID
				r.Result.Datasources[datasourcesCount].Optional = datasources1.Optional
				r.Result.Datasources[datasourcesCount].Status = datasources1.Status
			}
		}
		if len(resp.Result.DecisionMappings) > 0 {
			r.Result.DecisionMappings = make(map[string]tfTypes.SystemsV1RuleDecisionMappings)
			for systemsV1RuleDecisionMappingsKey, systemsV1RuleDecisionMappingsValue := range resp.Result.DecisionMappings {
				var systemsV1RuleDecisionMappingsResult tfTypes.SystemsV1RuleDecisionMappings
				if systemsV1RuleDecisionMappingsValue.Allowed == nil {
					systemsV1RuleDecisionMappingsResult.Allowed = nil
				} else {
					systemsV1RuleDecisionMappingsResult.Allowed = &tfTypes.SystemsV1AllowedMapping{}
					if systemsV1RuleDecisionMappingsValue.Allowed.Expected == nil {
						systemsV1RuleDecisionMappingsResult.Allowed.Expected = types.StringNull()
					} else {
						expectedResult, _ := json.Marshal(systemsV1RuleDecisionMappingsValue.Allowed.Expected)
						systemsV1RuleDecisionMappingsResult.Allowed.Expected = types.StringValue(string(expectedResult))
					}
					systemsV1RuleDecisionMappingsResult.Allowed.Negated = types.BoolPointerValue(systemsV1RuleDecisionMappingsValue.Allowed.Negated)
					systemsV1RuleDecisionMappingsResult.Allowed.Path = types.StringValue(systemsV1RuleDecisionMappingsValue.Allowed.Path)
				}
				systemsV1RuleDecisionMappingsResult.Columns = []tfTypes.SystemsV1ColumnMapping{}
				for columnsCount, columnsItem := range systemsV1RuleDecisionMappingsValue.Columns {
					var columns1 tfTypes.SystemsV1ColumnMapping
					columns1.Key = types.StringValue(columnsItem.Key)
					columns1.Path = types.StringValue(columnsItem.Path)
					columns1.Type = types.StringPointerValue(columnsItem.Type)
					if columnsCount+1 > len(systemsV1RuleDecisionMappingsResult.Columns) {
						systemsV1RuleDecisionMappingsResult.Columns = append(systemsV1RuleDecisionMappingsResult.Columns, columns1)
					} else {
						systemsV1RuleDecisionMappingsResult.Columns[columnsCount].Key = columns1.Key
						systemsV1RuleDecisionMappingsResult.Columns[columnsCount].Path = columns1.Path
						systemsV1RuleDecisionMappingsResult.Columns[columnsCount].Type = columns1.Type
					}
				}
				if systemsV1RuleDecisionMappingsValue.Reason == nil {
					systemsV1RuleDecisionMappingsResult.Reason = nil
				} else {
					systemsV1RuleDecisionMappingsResult.Reason = &tfTypes.SystemsV1ReasonMapping{}
					systemsV1RuleDecisionMappingsResult.Reason.Path = types.StringValue(systemsV1RuleDecisionMappingsValue.Reason.Path)
				}
				r.Result.DecisionMappings[systemsV1RuleDecisionMappingsKey] = systemsV1RuleDecisionMappingsResult
			}
		}
		if resp.Result.DeploymentParameters == nil {
			r.Result.DeploymentParameters = nil
		} else {
			r.Result.DeploymentParameters = &tfTypes.SystemsV1SystemDeploymentParameters{}
			r.Result.DeploymentParameters.DenyOnOpaFail = types.BoolPointerValue(resp.Result.DeploymentParameters.DenyOnOpaFail)
			if resp.Result.DeploymentParameters.Discovery == nil {
				r.Result.DeploymentParameters.Discovery = nil
			} else {
				r.Result.DeploymentParameters.Discovery = &tfTypes.TypeParameters{}
			}
			if resp.Result.DeploymentParameters.Extra == nil {
				r.Result.DeploymentParameters.Extra = nil
			} else {
				r.Result.DeploymentParameters.Extra = &tfTypes.TypeParameters{}
			}
			r.Result.DeploymentParameters.HTTPProxy = types.StringPointerValue(resp.Result.DeploymentParameters.HTTPProxy)
			r.Result.DeploymentParameters.HTTPSProxy = types.StringPointerValue(resp.Result.DeploymentParameters.HTTPSProxy)
			r.Result.DeploymentParameters.KubernetesVersion = types.StringPointerValue(resp.Result.DeploymentParameters.KubernetesVersion)
			r.Result.DeploymentParameters.MutatingWebhookName = types.StringPointerValue(resp.Result.DeploymentParameters.MutatingWebhookName)
			r.Result.DeploymentParameters.Namespace = types.StringPointerValue(resp.Result.DeploymentParameters.Namespace)
			r.Result.DeploymentParameters.NoProxy = types.StringPointerValue(resp.Result.DeploymentParameters.NoProxy)
			if resp.Result.DeploymentParameters.TimeoutSeconds != nil {
				r.Result.DeploymentParameters.TimeoutSeconds = types.Int64Value(int64(*resp.Result.DeploymentParameters.TimeoutSeconds))
			} else {
				r.Result.DeploymentParameters.TimeoutSeconds = types.Int64Null()
			}
			r.Result.DeploymentParameters.TrustedCaCerts = []types.String{}
			for _, v := range resp.Result.DeploymentParameters.TrustedCaCerts {
				r.Result.DeploymentParameters.TrustedCaCerts = append(r.Result.DeploymentParameters.TrustedCaCerts, types.StringValue(v))
			}
			r.Result.DeploymentParameters.TrustedContainerRegistry = types.StringPointerValue(resp.Result.DeploymentParameters.TrustedContainerRegistry)
		}
		r.Result.Description = types.StringPointerValue(resp.Result.Description)
		r.Result.ErrorSetting = types.StringPointerValue(resp.Result.ErrorSetting)
		if len(resp.Result.Errors) > 0 {
			r.Result.Errors = make(map[string]tfTypes.SystemsV1AgentErrors)
			for systemsV1AgentErrorsKey, systemsV1AgentErrorsValue := range resp.Result.Errors {
				var systemsV1AgentErrorsResult tfTypes.SystemsV1AgentErrors
				systemsV1AgentErrorsResult.Errors = []tfTypes.MetaV1Status{}
				for errorsCount, errorsItem := range systemsV1AgentErrorsValue.Errors {
					var errors2 tfTypes.MetaV1Status
					errors2.Code = types.StringValue(errorsItem.Code)
					errors2.Message = types.StringValue(errorsItem.Message)
					errors2.Timestamp = types.StringValue(errorsItem.Timestamp.Format(time.RFC3339Nano))
					if errorsCount+1 > len(systemsV1AgentErrorsResult.Errors) {
						systemsV1AgentErrorsResult.Errors = append(systemsV1AgentErrorsResult.Errors, errors2)
					} else {
						systemsV1AgentErrorsResult.Errors[errorsCount].Code = errors2.Code
						systemsV1AgentErrorsResult.Errors[errorsCount].Message = errors2.Message
						systemsV1AgentErrorsResult.Errors[errorsCount].Timestamp = errors2.Timestamp
					}
				}
				systemsV1AgentErrorsResult.Waiting = types.BoolValue(systemsV1AgentErrorsValue.Waiting)
				r.Result.Errors[systemsV1AgentErrorsKey] = systemsV1AgentErrorsResult
			}
		}
		if resp.Result.ExternalBundles == nil {
			r.Result.ExternalBundles = nil
		} else {
			r.Result.ExternalBundles = &tfTypes.SystemsV1ExternalBundleConfig{}
			if len(resp.Result.ExternalBundles.Bundles) > 0 {
				r.Result.ExternalBundles.Bundles = make(map[string]tfTypes.SystemsV1OpaConfigBundleDeclaration)
				for systemsV1OpaConfigBundleDeclarationKey, systemsV1OpaConfigBundleDeclarationValue := range resp.Result.ExternalBundles.Bundles {
					var systemsV1OpaConfigBundleDeclarationResult tfTypes.SystemsV1OpaConfigBundleDeclaration
					systemsV1OpaConfigBundleDeclarationResult.Persist = types.BoolPointerValue(systemsV1OpaConfigBundleDeclarationValue.Persist)
					if systemsV1OpaConfigBundleDeclarationValue.Polling == nil {
						systemsV1OpaConfigBundleDeclarationResult.Polling = nil
					} else {
						systemsV1OpaConfigBundleDeclarationResult.Polling = &tfTypes.SystemsV1PollingConfig{}
						systemsV1OpaConfigBundleDeclarationResult.Polling.LongPollingTimeoutSeconds = types.Int64PointerValue(systemsV1OpaConfigBundleDeclarationValue.Polling.LongPollingTimeoutSeconds)
						systemsV1OpaConfigBundleDeclarationResult.Polling.MaxDelaySeconds = types.Int64PointerValue(systemsV1OpaConfigBundleDeclarationValue.Polling.MaxDelaySeconds)
						systemsV1OpaConfigBundleDeclarationResult.Polling.MinDelaySeconds = types.Int64PointerValue(systemsV1OpaConfigBundleDeclarationValue.Polling.MinDelaySeconds)
					}
					systemsV1OpaConfigBundleDeclarationResult.Resource = types.StringPointerValue(systemsV1OpaConfigBundleDeclarationValue.Resource)
					systemsV1OpaConfigBundleDeclarationResult.Service = types.StringValue(systemsV1OpaConfigBundleDeclarationValue.Service)
					if systemsV1OpaConfigBundleDeclarationValue.Signing == nil {
						systemsV1OpaConfigBundleDeclarationResult.Signing = nil
					} else {
						systemsV1OpaConfigBundleDeclarationResult.Signing = &tfTypes.SystemsV1VerificationConfig{}
						systemsV1OpaConfigBundleDeclarationResult.Signing.ExcludeFiles = []types.String{}
						for _, v := range systemsV1OpaConfigBundleDeclarationValue.Signing.ExcludeFiles {
							systemsV1OpaConfigBundleDeclarationResult.Signing.ExcludeFiles = append(systemsV1OpaConfigBundleDeclarationResult.Signing.ExcludeFiles, types.StringValue(v))
						}
						systemsV1OpaConfigBundleDeclarationResult.Signing.Keyid = types.StringPointerValue(systemsV1OpaConfigBundleDeclarationValue.Signing.Keyid)
						if len(systemsV1OpaConfigBundleDeclarationValue.Signing.PublicKeys) > 0 {
							systemsV1OpaConfigBundleDeclarationResult.Signing.PublicKeys = make(map[string]tfTypes.SystemsV1KeyConfig)
							for systemsV1KeyConfigKey, systemsV1KeyConfigValue := range systemsV1OpaConfigBundleDeclarationValue.Signing.PublicKeys {
								var systemsV1KeyConfigResult tfTypes.SystemsV1KeyConfig
								systemsV1KeyConfigResult.Algorithm = types.StringPointerValue(systemsV1KeyConfigValue.Algorithm)
								systemsV1KeyConfigResult.Key = types.StringPointerValue(systemsV1KeyConfigValue.Key)
								systemsV1KeyConfigResult.PrivateKey = types.StringPointerValue(systemsV1KeyConfigValue.PrivateKey)
								systemsV1KeyConfigResult.Scope = types.StringPointerValue(systemsV1KeyConfigValue.Scope)
								systemsV1OpaConfigBundleDeclarationResult.Signing.PublicKeys[systemsV1KeyConfigKey] = systemsV1KeyConfigResult
							}
						}
						systemsV1OpaConfigBundleDeclarationResult.Signing.Scope = types.StringPointerValue(systemsV1OpaConfigBundleDeclarationValue.Signing.Scope)
					}
					systemsV1OpaConfigBundleDeclarationResult.SizeLimitBytes = types.Int64PointerValue(systemsV1OpaConfigBundleDeclarationValue.SizeLimitBytes)
					r.Result.ExternalBundles.Bundles[systemsV1OpaConfigBundleDeclarationKey] = systemsV1OpaConfigBundleDeclarationResult
				}
			}
			r.Result.ExternalBundles.Services = []tfTypes.SystemsV1OpaConfigServiceDeclaration{}
			if len(r.Result.ExternalBundles.Services) > len(resp.Result.ExternalBundles.Services) {
				r.Result.ExternalBundles.Services = r.Result.ExternalBundles.Services[:len(resp.Result.ExternalBundles.Services)]
			}
			for servicesCount, servicesItem := range resp.Result.ExternalBundles.Services {
				var services1 tfTypes.SystemsV1OpaConfigServiceDeclaration
				services1.AllowInsecureTLS = types.BoolPointerValue(servicesItem.AllowInsecureTLS)
				if servicesItem.Credentials == nil {
					services1.Credentials = nil
				} else {
					services1.Credentials = &tfTypes.SystemsV1OpaConfigServiceDeclarationCredentials{}
					if servicesItem.Credentials.AzureManagedIdentity == nil {
						services1.Credentials.AzureManagedIdentity = nil
					} else {
						services1.Credentials.AzureManagedIdentity = &tfTypes.SystemsV1AzureManagedIdentitiesAuthPlugin{}
						services1.Credentials.AzureManagedIdentity.APIVersion = types.StringValue(servicesItem.Credentials.AzureManagedIdentity.APIVersion)
						services1.Credentials.AzureManagedIdentity.ClientID = types.StringValue(servicesItem.Credentials.AzureManagedIdentity.ClientID)
						services1.Credentials.AzureManagedIdentity.Endpoint = types.StringValue(servicesItem.Credentials.AzureManagedIdentity.Endpoint)
						services1.Credentials.AzureManagedIdentity.MiResID = types.StringValue(servicesItem.Credentials.AzureManagedIdentity.MiResID)
						services1.Credentials.AzureManagedIdentity.ObjectID = types.StringValue(servicesItem.Credentials.AzureManagedIdentity.ObjectID)
						services1.Credentials.AzureManagedIdentity.Resource = types.StringValue(servicesItem.Credentials.AzureManagedIdentity.Resource)
					}
					if servicesItem.Credentials.Bearer == nil {
						services1.Credentials.Bearer = nil
					} else {
						services1.Credentials.Bearer = &tfTypes.SystemsV1BearerAuthPlugin{}
						services1.Credentials.Bearer.Scheme = types.StringPointerValue(servicesItem.Credentials.Bearer.Scheme)
						services1.Credentials.Bearer.Token = types.StringValue(servicesItem.Credentials.Bearer.Token)
						services1.Credentials.Bearer.TokenPath = types.StringValue(servicesItem.Credentials.Bearer.TokenPath)
					}
					if servicesItem.Credentials.ClientTLS == nil {
						services1.Credentials.ClientTLS = nil
					} else {
						services1.Credentials.ClientTLS = &tfTypes.SystemsV1ClientTLSAuthPlugin{}
						services1.Credentials.ClientTLS.Cert = types.StringValue(servicesItem.Credentials.ClientTLS.Cert)
						services1.Credentials.ClientTLS.PrivateKey = types.StringValue(servicesItem.Credentials.ClientTLS.PrivateKey)
						services1.Credentials.ClientTLS.PrivateKeyPassphrase = types.StringPointerValue(servicesItem.Credentials.ClientTLS.PrivateKeyPassphrase)
					}
					if servicesItem.Credentials.GcpMetadata == nil {
						services1.Credentials.GcpMetadata = nil
					} else {
						services1.Credentials.GcpMetadata = &tfTypes.SystemsV1GcpMetadataAuthPlugin{}
						services1.Credentials.GcpMetadata.AccessTokenPath = types.StringValue(servicesItem.Credentials.GcpMetadata.AccessTokenPath)
						services1.Credentials.GcpMetadata.Audience = types.StringValue(servicesItem.Credentials.GcpMetadata.Audience)
						services1.Credentials.GcpMetadata.Endpoint = types.StringValue(servicesItem.Credentials.GcpMetadata.Endpoint)
						services1.Credentials.GcpMetadata.IDTokenPath = types.StringValue(servicesItem.Credentials.GcpMetadata.IDTokenPath)
						services1.Credentials.GcpMetadata.Scopes = []types.String{}
						for _, v := range servicesItem.Credentials.GcpMetadata.Scopes {
							services1.Credentials.GcpMetadata.Scopes = append(services1.Credentials.GcpMetadata.Scopes, types.StringValue(v))
						}
					}
					if servicesItem.Credentials.Oauth2 == nil {
						services1.Credentials.Oauth2 = nil
					} else {
						services1.Credentials.Oauth2 = &tfTypes.SystemsV1Oauth2ClientCredentialsAuthPlugin{}
						if len(servicesItem.Credentials.Oauth2.AdditionalHeaders) > 0 {
							services1.Credentials.Oauth2.AdditionalHeaders = make(map[string]types.String)
							for key3, value1 := range servicesItem.Credentials.Oauth2.AdditionalHeaders {
								services1.Credentials.Oauth2.AdditionalHeaders[key3] = types.StringValue(value1)
							}
						}
						if len(servicesItem.Credentials.Oauth2.AdditionalParameters) > 0 {
							services1.Credentials.Oauth2.AdditionalParameters = make(map[string]types.String)
							for key4, value2 := range servicesItem.Credentials.Oauth2.AdditionalParameters {
								services1.Credentials.Oauth2.AdditionalParameters[key4] = types.StringValue(value2)
							}
						}
						services1.Credentials.Oauth2.ClientID = types.StringValue(servicesItem.Credentials.Oauth2.ClientID)
						services1.Credentials.Oauth2.ClientSecret = types.StringValue(servicesItem.Credentials.Oauth2.ClientSecret)
						services1.Credentials.Oauth2.GrantType = types.StringValue(servicesItem.Credentials.Oauth2.GrantType)
						services1.Credentials.Oauth2.IncludeJtiClaim = types.BoolValue(servicesItem.Credentials.Oauth2.IncludeJtiClaim)
						services1.Credentials.Oauth2.Scopes = []types.String{}
						for _, v := range servicesItem.Credentials.Oauth2.Scopes {
							services1.Credentials.Oauth2.Scopes = append(services1.Credentials.Oauth2.Scopes, types.StringValue(v))
						}
						services1.Credentials.Oauth2.SigningKey = types.StringValue(servicesItem.Credentials.Oauth2.SigningKey)
						services1.Credentials.Oauth2.Thumbprint = types.StringValue(servicesItem.Credentials.Oauth2.Thumbprint)
						services1.Credentials.Oauth2.TokenURL = types.StringValue(servicesItem.Credentials.Oauth2.TokenURL)
					}
					services1.Credentials.Plugin = types.StringPointerValue(servicesItem.Credentials.Plugin)
					if servicesItem.Credentials.S3Signing == nil {
						services1.Credentials.S3Signing = nil
					} else {
						services1.Credentials.S3Signing = &tfTypes.SystemsV1AwsSigningAuthPlugin{}
						if servicesItem.Credentials.S3Signing.EnvironmentCredentials == nil {
							services1.Credentials.S3Signing.EnvironmentCredentials = types.StringNull()
						} else {
							environmentCredentialsResult, _ := json.Marshal(servicesItem.Credentials.S3Signing.EnvironmentCredentials)
							services1.Credentials.S3Signing.EnvironmentCredentials = types.StringValue(string(environmentCredentialsResult))
						}
						if servicesItem.Credentials.S3Signing.MetadataCredentials == nil {
							services1.Credentials.S3Signing.MetadataCredentials = nil
						} else {
							services1.Credentials.S3Signing.MetadataCredentials = &tfTypes.SystemsV1BundleDistributionS3ConfigOpaCredentialsMetadataCredentials{}
							services1.Credentials.S3Signing.MetadataCredentials.AwsRegion = types.StringValue(servicesItem.Credentials.S3Signing.MetadataCredentials.AwsRegion)
							services1.Credentials.S3Signing.MetadataCredentials.IamRole = types.StringPointerValue(servicesItem.Credentials.S3Signing.MetadataCredentials.IamRole)
						}
						if servicesItem.Credentials.S3Signing.ProfileCredentials == nil {
							services1.Credentials.S3Signing.ProfileCredentials = nil
						} else {
							services1.Credentials.S3Signing.ProfileCredentials = &tfTypes.SystemsV1AwsProfileCredentialService{}
							services1.Credentials.S3Signing.ProfileCredentials.AwsRegion = types.StringValue(servicesItem.Credentials.S3Signing.ProfileCredentials.AwsRegion)
							services1.Credentials.S3Signing.ProfileCredentials.Path = types.StringPointerValue(servicesItem.Credentials.S3Signing.ProfileCredentials.Path)
							services1.Credentials.S3Signing.ProfileCredentials.Profile = types.StringPointerValue(servicesItem.Credentials.S3Signing.ProfileCredentials.Profile)
						}
						services1.Credentials.S3Signing.Service = types.StringPointerValue(servicesItem.Credentials.S3Signing.Service)
						if servicesItem.Credentials.S3Signing.WebIdentityCredentials == nil {
							services1.Credentials.S3Signing.WebIdentityCredentials = nil
						} else {
							services1.Credentials.S3Signing.WebIdentityCredentials = &tfTypes.SystemsV1BundleDistributionS3ConfigOpaCredentialsWebIdentityCredentials{}
							services1.Credentials.S3Signing.WebIdentityCredentials.AwsRegion = types.StringValue(servicesItem.Credentials.S3Signing.WebIdentityCredentials.AwsRegion)
							services1.Credentials.S3Signing.WebIdentityCredentials.SessionName = types.StringValue(servicesItem.Credentials.S3Signing.WebIdentityCredentials.SessionName)
						}
					}
				}
				if len(servicesItem.Headers) > 0 {
					services1.Headers = make(map[string]types.String)
					for key5, value3 := range servicesItem.Headers {
						services1.Headers[key5] = types.StringValue(value3)
					}
				}
				if len(servicesItem.Keys) > 0 {
					services1.Keys = make(map[string]tfTypes.KeysConfig)
					for keysConfigKey, keysConfigValue := range servicesItem.Keys {
						var keysConfigResult tfTypes.KeysConfig
						keysConfigResult.Algorithm = types.StringValue(keysConfigValue.Algorithm)
						keysConfigResult.Key = types.StringValue(keysConfigValue.Key)
						keysConfigResult.PrivateKey = types.StringValue(keysConfigValue.PrivateKey)
						keysConfigResult.Scope = types.StringValue(keysConfigValue.Scope)
						services1.Keys[keysConfigKey] = keysConfigResult
					}
				}
				services1.Name = types.StringValue(servicesItem.Name)
				services1.ResponseHeaderTimeoutSeconds = types.Int64PointerValue(servicesItem.ResponseHeaderTimeoutSeconds)
				if servicesItem.TLS == nil {
					services1.TLS = nil
				} else {
					services1.TLS = &tfTypes.SystemsV1ServerTLSConfig{}
					services1.TLS.CaCert = types.StringPointerValue(servicesItem.TLS.CaCert)
					services1.TLS.SystemCaRequired = types.BoolPointerValue(servicesItem.TLS.SystemCaRequired)
				}
				services1.Type = types.StringPointerValue(servicesItem.Type)
				services1.URL = types.StringValue(servicesItem.URL)
				if servicesCount+1 > len(r.Result.ExternalBundles.Services) {
					r.Result.ExternalBundles.Services = append(r.Result.ExternalBundles.Services, services1)
				} else {
					r.Result.ExternalBundles.Services[servicesCount].AllowInsecureTLS = services1.AllowInsecureTLS
					r.Result.ExternalBundles.Services[servicesCount].Credentials = services1.Credentials
					r.Result.ExternalBundles.Services[servicesCount].Headers = services1.Headers
					r.Result.ExternalBundles.Services[servicesCount].Keys = services1.Keys
					r.Result.ExternalBundles.Services[servicesCount].Name = services1.Name
					r.Result.ExternalBundles.Services[servicesCount].ResponseHeaderTimeoutSeconds = services1.ResponseHeaderTimeoutSeconds
					r.Result.ExternalBundles.Services[servicesCount].TLS = services1.TLS
					r.Result.ExternalBundles.Services[servicesCount].Type = services1.Type
					r.Result.ExternalBundles.Services[servicesCount].URL = services1.URL
				}
			}
		}
		r.Result.ExternalID = types.StringPointerValue(resp.Result.ExternalID)
		r.Result.FilterStacks = types.BoolPointerValue(resp.Result.FilterStacks)
		r.Result.ID = types.StringValue(resp.Result.ID)
		r.Result.KafkaTopic = types.StringPointerValue(resp.Result.KafkaTopic)
		r.Result.MatchingStacks = []types.String{}
		for _, v := range resp.Result.MatchingStacks {
			r.Result.MatchingStacks = append(r.Result.MatchingStacks, types.StringValue(v))
		}
		if resp.Result.Metadata.CreatedAt != nil {
			r.Result.Metadata.CreatedAt = types.StringValue(resp.Result.Metadata.CreatedAt.Format(time.RFC3339Nano))
		} else {
			r.Result.Metadata.CreatedAt = types.StringNull()
		}
		r.Result.Metadata.CreatedBy = types.StringPointerValue(resp.Result.Metadata.CreatedBy)
		r.Result.Metadata.CreatedThrough = types.StringPointerValue(resp.Result.Metadata.CreatedThrough)
		if resp.Result.Metadata.LastModifiedAt != nil {
			r.Result.Metadata.LastModifiedAt = types.StringValue(resp.Result.Metadata.LastModifiedAt.Format(time.RFC3339Nano))
		} else {
			r.Result.Metadata.LastModifiedAt = types.StringNull()
		}
		r.Result.Metadata.LastModifiedBy = types.StringPointerValue(resp.Result.Metadata.LastModifiedBy)
		r.Result.Metadata.LastModifiedThrough = types.StringPointerValue(resp.Result.Metadata.LastModifiedThrough)
		r.Result.MigrationHistory = []tfTypes.SystemsV1MigrationRecord{}
		if len(r.Result.MigrationHistory) > len(resp.Result.MigrationHistory) {
			r.Result.MigrationHistory = r.Result.MigrationHistory[:len(resp.Result.MigrationHistory)]
		}
		for migrationHistoryCount, migrationHistoryItem := range resp.Result.MigrationHistory {
			var migrationHistory1 tfTypes.SystemsV1MigrationRecord
			migrationHistory1.From = types.StringValue(migrationHistoryItem.From)
			migrationHistory1.InitiatedBy = types.StringValue(migrationHistoryItem.InitiatedBy)
			migrationHistory1.InitiatingUser = types.StringValue(migrationHistoryItem.InitiatingUser)
			migrationHistory1.MigratedAt = types.StringValue(migrationHistoryItem.MigratedAt.Format(time.RFC3339Nano))
			migrationHistory1.Recovered = types.BoolPointerValue(migrationHistoryItem.Recovered)
			migrationHistory1.To = types.StringValue(migrationHistoryItem.To)
			if migrationHistoryCount+1 > len(r.Result.MigrationHistory) {
				r.Result.MigrationHistory = append(r.Result.MigrationHistory, migrationHistory1)
			} else {
				r.Result.MigrationHistory[migrationHistoryCount].From = migrationHistory1.From
				r.Result.MigrationHistory[migrationHistoryCount].InitiatedBy = migrationHistory1.InitiatedBy
				r.Result.MigrationHistory[migrationHistoryCount].InitiatingUser = migrationHistory1.InitiatingUser
				r.Result.MigrationHistory[migrationHistoryCount].MigratedAt = migrationHistory1.MigratedAt
				r.Result.MigrationHistory[migrationHistoryCount].Recovered = migrationHistory1.Recovered
				r.Result.MigrationHistory[migrationHistoryCount].To = migrationHistory1.To
			}
		}
		r.Result.MinimumOpaVersion = types.StringPointerValue(resp.Result.MinimumOpaVersion)
		r.Result.MockOpaEnabled = types.BoolPointerValue(resp.Result.MockOpaEnabled)
		r.Result.Name = types.StringValue(resp.Result.Name)
		r.Result.Policies = []tfTypes.SystemsV1PolicyConfig{}
		if len(r.Result.Policies) > len(resp.Result.Policies) {
			r.Result.Policies = r.Result.Policies[:len(resp.Result.Policies)]
		}
		for policiesCount, policiesItem := range resp.Result.Policies {
			var policies1 tfTypes.SystemsV1PolicyConfig
			policies1.Created = types.StringPointerValue(policiesItem.Created)
			policies1.Enforcement.Enforced = types.BoolValue(policiesItem.Enforcement.Enforced)
			policies1.Enforcement.Type = types.StringValue(policiesItem.Enforcement.Type)
			policies1.ID = types.StringValue(policiesItem.ID)
			policies1.Modules = []tfTypes.SystemsV1Module{}
			for modulesCount, modulesItem := range policiesItem.Modules {
				var modules1 tfTypes.SystemsV1Module
				modules1.Name = types.StringValue(modulesItem.Name)
				modules1.Placeholder = types.BoolPointerValue(modulesItem.Placeholder)
				modules1.ReadOnly = types.BoolValue(modulesItem.ReadOnly)
				if modulesItem.Rules == nil {
					modules1.Rules = nil
				} else {
					modules1.Rules = &tfTypes.PoliciesV1RuleCounts{}
					modules1.Rules.Allow = types.Int64Value(int64(modulesItem.Rules.Allow))
					modules1.Rules.Deny = types.Int64Value(int64(modulesItem.Rules.Deny))
					modules1.Rules.Enforce = types.Int64Value(int64(modulesItem.Rules.Enforce))
					modules1.Rules.Ignore = types.Int64Value(int64(modulesItem.Rules.Ignore))
					modules1.Rules.Monitor = types.Int64Value(int64(modulesItem.Rules.Monitor))
					modules1.Rules.Notify = types.Int64Value(int64(modulesItem.Rules.Notify))
					modules1.Rules.Other = types.Int64Value(int64(modulesItem.Rules.Other))
					modules1.Rules.Test = types.Int64Value(int64(modulesItem.Rules.Test))
					modules1.Rules.Total = types.Int64Value(int64(modulesItem.Rules.Total))
				}
				if modulesCount+1 > len(policies1.Modules) {
					policies1.Modules = append(policies1.Modules, modules1)
				} else {
					policies1.Modules[modulesCount].Name = modules1.Name
					policies1.Modules[modulesCount].Placeholder = modules1.Placeholder
					policies1.Modules[modulesCount].ReadOnly = modules1.ReadOnly
					policies1.Modules[modulesCount].Rules = modules1.Rules
				}
			}
			if policiesItem.Rules == nil {
				policies1.Rules = nil
			} else {
				policies1.Rules = &tfTypes.PoliciesV1RuleCounts{}
				policies1.Rules.Allow = types.Int64Value(int64(policiesItem.Rules.Allow))
				policies1.Rules.Deny = types.Int64Value(int64(policiesItem.Rules.Deny))
				policies1.Rules.Enforce = types.Int64Value(int64(policiesItem.Rules.Enforce))
				policies1.Rules.Ignore = types.Int64Value(int64(policiesItem.Rules.Ignore))
				policies1.Rules.Monitor = types.Int64Value(int64(policiesItem.Rules.Monitor))
				policies1.Rules.Notify = types.Int64Value(int64(policiesItem.Rules.Notify))
				policies1.Rules.Other = types.Int64Value(int64(policiesItem.Rules.Other))
				policies1.Rules.Test = types.Int64Value(int64(policiesItem.Rules.Test))
				policies1.Rules.Total = types.Int64Value(int64(policiesItem.Rules.Total))
			}
			policies1.Type = types.StringValue(policiesItem.Type)
			if policiesCount+1 > len(r.Result.Policies) {
				r.Result.Policies = append(r.Result.Policies, policies1)
			} else {
				r.Result.Policies[policiesCount].Created = policies1.Created
				r.Result.Policies[policiesCount].Enforcement = policies1.Enforcement
				r.Result.Policies[policiesCount].ID = policies1.ID
				r.Result.Policies[policiesCount].Modules = policies1.Modules
				r.Result.Policies[policiesCount].Rules = policies1.Rules
				r.Result.Policies[policiesCount].Type = policies1.Type
			}
		}
		r.Result.ReadOnly = types.BoolPointerValue(resp.Result.ReadOnly)
		if resp.Result.SourceControl == nil {
			r.Result.SourceControl = nil
		} else {
			r.Result.SourceControl = &tfTypes.GitV1SourceControlConfig{}
			r.Result.SourceControl.Origin.Commit = types.StringValue(resp.Result.SourceControl.Origin.Commit)
			r.Result.SourceControl.Origin.Credentials = types.StringValue(resp.Result.SourceControl.Origin.Credentials)
			r.Result.SourceControl.Origin.Path = types.StringValue(resp.Result.SourceControl.Origin.Path)
			r.Result.SourceControl.Origin.Reference = types.StringValue(resp.Result.SourceControl.Origin.Reference)
			if resp.Result.SourceControl.Origin.SSHCredentials == nil {
				r.Result.SourceControl.Origin.SSHCredentials = nil
			} else {
				r.Result.SourceControl.Origin.SSHCredentials = &tfTypes.GitV1SSHCredentials{}
				r.Result.SourceControl.Origin.SSHCredentials.Passphrase = types.StringValue(resp.Result.SourceControl.Origin.SSHCredentials.Passphrase)
				r.Result.SourceControl.Origin.SSHCredentials.PrivateKey = types.StringValue(resp.Result.SourceControl.Origin.SSHCredentials.PrivateKey)
			}
			r.Result.SourceControl.Origin.URL = types.StringValue(resp.Result.SourceControl.Origin.URL)
		}
		r.Result.Status = types.StringValue(resp.Result.Status)
		r.Result.Tokens = []tfTypes.TokensV1Token{}
		if len(r.Result.Tokens) > len(resp.Result.Tokens) {
			r.Result.Tokens = r.Result.Tokens[:len(resp.Result.Tokens)]
		}
		for tokensCount, tokensItem := range resp.Result.Tokens {
			var tokens1 tfTypes.TokensV1Token
			tokens1.AllowPathPatterns = []types.String{}
			for _, v := range tokensItem.AllowPathPatterns {
				tokens1.AllowPathPatterns = append(tokens1.AllowPathPatterns, types.StringValue(v))
			}
			tokens1.Description = types.StringValue(tokensItem.Description)
			if tokensItem.Expires != nil {
				tokens1.Expires = types.StringValue(tokensItem.Expires.Format(time.RFC3339Nano))
			} else {
				tokens1.Expires = types.StringNull()
			}
			tokens1.ID = types.StringValue(tokensItem.ID)
			if tokensItem.Metadata.CreatedAt != nil {
				tokens1.Metadata.CreatedAt = types.StringValue(tokensItem.Metadata.CreatedAt.Format(time.RFC3339Nano))
			} else {
				tokens1.Metadata.CreatedAt = types.StringNull()
			}
			tokens1.Metadata.CreatedBy = types.StringPointerValue(tokensItem.Metadata.CreatedBy)
			tokens1.Metadata.CreatedThrough = types.StringPointerValue(tokensItem.Metadata.CreatedThrough)
			if tokensItem.Metadata.LastModifiedAt != nil {
				tokens1.Metadata.LastModifiedAt = types.StringValue(tokensItem.Metadata.LastModifiedAt.Format(time.RFC3339Nano))
			} else {
				tokens1.Metadata.LastModifiedAt = types.StringNull()
			}
			tokens1.Metadata.LastModifiedBy = types.StringPointerValue(tokensItem.Metadata.LastModifiedBy)
			tokens1.Metadata.LastModifiedThrough = types.StringPointerValue(tokensItem.Metadata.LastModifiedThrough)
			tokens1.Token = types.StringPointerValue(tokensItem.Token)
			tokens1.TTL = types.StringValue(tokensItem.TTL)
			tokens1.Uses = types.Int64PointerValue(tokensItem.Uses)
			if tokensCount+1 > len(r.Result.Tokens) {
				r.Result.Tokens = append(r.Result.Tokens, tokens1)
			} else {
				r.Result.Tokens[tokensCount].AllowPathPatterns = tokens1.AllowPathPatterns
				r.Result.Tokens[tokensCount].Description = tokens1.Description
				r.Result.Tokens[tokensCount].Expires = tokens1.Expires
				r.Result.Tokens[tokensCount].ID = tokens1.ID
				r.Result.Tokens[tokensCount].Metadata = tokens1.Metadata
				r.Result.Tokens[tokensCount].Token = tokens1.Token
				r.Result.Tokens[tokensCount].TTL = tokens1.TTL
				r.Result.Tokens[tokensCount].Uses = tokens1.Uses
			}
		}
		r.Result.Type = types.StringValue(resp.Result.Type)
		if resp.Result.TypeParameters == nil {
			r.Result.TypeParameters = nil
		} else {
			r.Result.TypeParameters = &tfTypes.TypeParameters{}
		}
		if len(resp.Result.Uninstall) > 0 {
			r.Result.Uninstall = make(map[string]types.String)
			for key7, value4 := range resp.Result.Uninstall {
				r.Result.Uninstall[key7] = types.StringValue(value4)
			}
		}
	}
}

func (r *SystemResourceModel) ToSharedSystemsV1SystemsPutRequest() *shared.SystemsV1SystemsPutRequest {
	var bundleDownload *shared.SystemsV1BundleDownloadConfig
	if r.BundleDownload != nil {
		deltaBundles := new(bool)
		if !r.BundleDownload.DeltaBundles.IsUnknown() && !r.BundleDownload.DeltaBundles.IsNull() {
			*deltaBundles = r.BundleDownload.DeltaBundles.ValueBool()
		} else {
			deltaBundles = nil
		}
		bundleDownload = &shared.SystemsV1BundleDownloadConfig{
			DeltaBundles: deltaBundles,
		}
	}
	var bundleRegistry *shared.SystemsV1BundleRegistryConfig
	if r.BundleRegistry != nil {
		disableBundleCompatibilityCheck := new(bool)
		if !r.BundleRegistry.DisableBundleCompatibilityCheck.IsUnknown() && !r.BundleRegistry.DisableBundleCompatibilityCheck.IsNull() {
			*disableBundleCompatibilityCheck = r.BundleRegistry.DisableBundleCompatibilityCheck.ValueBool()
		} else {
			disableBundleCompatibilityCheck = nil
		}
		var distributionS3 *shared.SystemsV1BundleDistributionS3Config
		if r.BundleRegistry.DistributionS3 != nil {
			accessKeys := new(string)
			if !r.BundleRegistry.DistributionS3.AccessKeys.IsUnknown() && !r.BundleRegistry.DistributionS3.AccessKeys.IsNull() {
				*accessKeys = r.BundleRegistry.DistributionS3.AccessKeys.ValueString()
			} else {
				accessKeys = nil
			}
			var bucket string
			bucket = r.BundleRegistry.DistributionS3.Bucket.ValueString()

			contextPath := new(string)
			if !r.BundleRegistry.DistributionS3.ContextPath.IsUnknown() && !r.BundleRegistry.DistributionS3.ContextPath.IsNull() {
				*contextPath = r.BundleRegistry.DistributionS3.ContextPath.ValueString()
			} else {
				contextPath = nil
			}
			discoveryPath := new(string)
			if !r.BundleRegistry.DistributionS3.DiscoveryPath.IsUnknown() && !r.BundleRegistry.DistributionS3.DiscoveryPath.IsNull() {
				*discoveryPath = r.BundleRegistry.DistributionS3.DiscoveryPath.ValueString()
			} else {
				discoveryPath = nil
			}
			endpoint := new(string)
			if !r.BundleRegistry.DistributionS3.Endpoint.IsUnknown() && !r.BundleRegistry.DistributionS3.Endpoint.IsNull() {
				*endpoint = r.BundleRegistry.DistributionS3.Endpoint.ValueString()
			} else {
				endpoint = nil
			}
			var opaCredentials *shared.SystemsV1BundleDistributionS3ConfigOpaCredentials
			if r.BundleRegistry.DistributionS3.OpaCredentials != nil {
				var environmentCredentials *shared.SystemsV1BundleDistributionS3ConfigOpaCredentialsEnvironmentCredentials
				if r.BundleRegistry.DistributionS3.OpaCredentials.EnvironmentCredentials != nil {
					environmentCredentials = &shared.SystemsV1BundleDistributionS3ConfigOpaCredentialsEnvironmentCredentials{}
				}
				var metadataCredentials *shared.SystemsV1BundleDistributionS3ConfigOpaCredentialsMetadataCredentials
				if r.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials != nil {
					var awsRegion string
					awsRegion = r.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials.AwsRegion.ValueString()

					iamRole := new(string)
					if !r.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials.IamRole.IsUnknown() && !r.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials.IamRole.IsNull() {
						*iamRole = r.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials.IamRole.ValueString()
					} else {
						iamRole = nil
					}
					metadataCredentials = &shared.SystemsV1BundleDistributionS3ConfigOpaCredentialsMetadataCredentials{
						AwsRegion: awsRegion,
						IamRole:   iamRole,
					}
				}
				var webIdentityCredentials *shared.SystemsV1BundleDistributionS3ConfigOpaCredentialsWebIdentityCredentials
				if r.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials != nil {
					var awsRegion1 string
					awsRegion1 = r.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials.AwsRegion.ValueString()

					var sessionName string
					sessionName = r.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials.SessionName.ValueString()

					webIdentityCredentials = &shared.SystemsV1BundleDistributionS3ConfigOpaCredentialsWebIdentityCredentials{
						AwsRegion:   awsRegion1,
						SessionName: sessionName,
					}
				}
				opaCredentials = &shared.SystemsV1BundleDistributionS3ConfigOpaCredentials{
					EnvironmentCredentials: environmentCredentials,
					MetadataCredentials:    metadataCredentials,
					WebIdentityCredentials: webIdentityCredentials,
				}
			}
			policyPath := new(string)
			if !r.BundleRegistry.DistributionS3.PolicyPath.IsUnknown() && !r.BundleRegistry.DistributionS3.PolicyPath.IsNull() {
				*policyPath = r.BundleRegistry.DistributionS3.PolicyPath.ValueString()
			} else {
				policyPath = nil
			}
			var region string
			region = r.BundleRegistry.DistributionS3.Region.ValueString()

			roleArn := new(string)
			if !r.BundleRegistry.DistributionS3.RoleArn.IsUnknown() && !r.BundleRegistry.DistributionS3.RoleArn.IsNull() {
				*roleArn = r.BundleRegistry.DistributionS3.RoleArn.ValueString()
			} else {
				roleArn = nil
			}
			distributionS3 = &shared.SystemsV1BundleDistributionS3Config{
				AccessKeys:     accessKeys,
				Bucket:         bucket,
				ContextPath:    contextPath,
				DiscoveryPath:  discoveryPath,
				Endpoint:       endpoint,
				OpaCredentials: opaCredentials,
				PolicyPath:     policyPath,
				Region:         region,
				RoleArn:        roleArn,
			}
		}
		var entrypoints []string = []string{}
		for _, entrypointsItem := range r.BundleRegistry.Entrypoints {
			entrypoints = append(entrypoints, entrypointsItem.ValueString())
		}
		manualDeployment := new(bool)
		if !r.BundleRegistry.ManualDeployment.IsUnknown() && !r.BundleRegistry.ManualDeployment.IsNull() {
			*manualDeployment = r.BundleRegistry.ManualDeployment.ValueBool()
		} else {
			manualDeployment = nil
		}
		manualDeploymentOverrides := make(map[string]bool)
		for manualDeploymentOverridesKey, manualDeploymentOverridesValue := range r.BundleRegistry.ManualDeploymentOverrides {
			var manualDeploymentOverridesInst bool
			manualDeploymentOverridesInst = manualDeploymentOverridesValue.ValueBool()

			manualDeploymentOverrides[manualDeploymentOverridesKey] = manualDeploymentOverridesInst
		}
		maxBundles := new(int64)
		if !r.BundleRegistry.MaxBundles.IsUnknown() && !r.BundleRegistry.MaxBundles.IsNull() {
			*maxBundles = r.BundleRegistry.MaxBundles.ValueInt64()
		} else {
			maxBundles = nil
		}
		maxDeployedBundles := new(int64)
		if !r.BundleRegistry.MaxDeployedBundles.IsUnknown() && !r.BundleRegistry.MaxDeployedBundles.IsNull() {
			*maxDeployedBundles = r.BundleRegistry.MaxDeployedBundles.ValueInt64()
		} else {
			maxDeployedBundles = nil
		}
		optimizationLevel := new(int)
		if !r.BundleRegistry.OptimizationLevel.IsUnknown() && !r.BundleRegistry.OptimizationLevel.IsNull() {
			*optimizationLevel = int(r.BundleRegistry.OptimizationLevel.ValueInt64())
		} else {
			optimizationLevel = nil
		}
		bundleRegistry = &shared.SystemsV1BundleRegistryConfig{
			DisableBundleCompatibilityCheck: disableBundleCompatibilityCheck,
			DistributionS3:                  distributionS3,
			Entrypoints:                     entrypoints,
			ManualDeployment:                manualDeployment,
			ManualDeploymentOverrides:       manualDeploymentOverrides,
			MaxBundles:                      maxBundles,
			MaxDeployedBundles:              maxDeployedBundles,
			OptimizationLevel:               optimizationLevel,
		}
	}
	contextBundleDataOnly := new(bool)
	if !r.ContextBundleDataOnly.IsUnknown() && !r.ContextBundleDataOnly.IsNull() {
		*contextBundleDataOnly = r.ContextBundleDataOnly.ValueBool()
	} else {
		contextBundleDataOnly = nil
	}
	var contextBundleRoots []string = []string{}
	for _, contextBundleRootsItem := range r.ContextBundleRoots {
		contextBundleRoots = append(contextBundleRoots, contextBundleRootsItem.ValueString())
	}
	decisionMappings := make(map[string]shared.SystemsV1RuleDecisionMappings)
	for decisionMappingsKey, decisionMappingsValue := range r.DecisionMappings {
		var allowed *shared.SystemsV1AllowedMapping
		if decisionMappingsValue.Allowed != nil {
			var expected interface{}
			if !decisionMappingsValue.Allowed.Expected.IsUnknown() && !decisionMappingsValue.Allowed.Expected.IsNull() {
				_ = json.Unmarshal([]byte(decisionMappingsValue.Allowed.Expected.ValueString()), &expected)
			}
			negated := new(bool)
			if !decisionMappingsValue.Allowed.Negated.IsUnknown() && !decisionMappingsValue.Allowed.Negated.IsNull() {
				*negated = decisionMappingsValue.Allowed.Negated.ValueBool()
			} else {
				negated = nil
			}
			var path string
			path = decisionMappingsValue.Allowed.Path.ValueString()

			allowed = &shared.SystemsV1AllowedMapping{
				Expected: expected,
				Negated:  negated,
				Path:     path,
			}
		}
		var columns []shared.SystemsV1ColumnMapping = []shared.SystemsV1ColumnMapping{}
		for _, columnsItem := range decisionMappingsValue.Columns {
			var key string
			key = columnsItem.Key.ValueString()

			var path1 string
			path1 = columnsItem.Path.ValueString()

			typeVar := new(string)
			if !columnsItem.Type.IsUnknown() && !columnsItem.Type.IsNull() {
				*typeVar = columnsItem.Type.ValueString()
			} else {
				typeVar = nil
			}
			columns = append(columns, shared.SystemsV1ColumnMapping{
				Key:  key,
				Path: path1,
				Type: typeVar,
			})
		}
		var reason *shared.SystemsV1ReasonMapping
		if decisionMappingsValue.Reason != nil {
			var path2 string
			path2 = decisionMappingsValue.Reason.Path.ValueString()

			reason = &shared.SystemsV1ReasonMapping{
				Path: path2,
			}
		}
		decisionMappingsInst := shared.SystemsV1RuleDecisionMappings{
			Allowed: allowed,
			Columns: columns,
			Reason:  reason,
		}
		decisionMappings[decisionMappingsKey] = decisionMappingsInst
	}
	var deploymentParameters *shared.SystemsV1SystemDeploymentParameters
	if r.DeploymentParameters != nil {
		denyOnOpaFail := new(bool)
		if !r.DeploymentParameters.DenyOnOpaFail.IsUnknown() && !r.DeploymentParameters.DenyOnOpaFail.IsNull() {
			*denyOnOpaFail = r.DeploymentParameters.DenyOnOpaFail.ValueBool()
		} else {
			denyOnOpaFail = nil
		}
		var discovery *shared.Discovery
		if r.DeploymentParameters.Discovery != nil {
			discovery = &shared.Discovery{}
		}
		var extra *shared.Extra
		if r.DeploymentParameters.Extra != nil {
			extra = &shared.Extra{}
		}
		httpProxy := new(string)
		if !r.DeploymentParameters.HTTPProxy.IsUnknown() && !r.DeploymentParameters.HTTPProxy.IsNull() {
			*httpProxy = r.DeploymentParameters.HTTPProxy.ValueString()
		} else {
			httpProxy = nil
		}
		httpsProxy := new(string)
		if !r.DeploymentParameters.HTTPSProxy.IsUnknown() && !r.DeploymentParameters.HTTPSProxy.IsNull() {
			*httpsProxy = r.DeploymentParameters.HTTPSProxy.ValueString()
		} else {
			httpsProxy = nil
		}
		kubernetesVersion := new(string)
		if !r.DeploymentParameters.KubernetesVersion.IsUnknown() && !r.DeploymentParameters.KubernetesVersion.IsNull() {
			*kubernetesVersion = r.DeploymentParameters.KubernetesVersion.ValueString()
		} else {
			kubernetesVersion = nil
		}
		mutatingWebhookName := new(string)
		if !r.DeploymentParameters.MutatingWebhookName.IsUnknown() && !r.DeploymentParameters.MutatingWebhookName.IsNull() {
			*mutatingWebhookName = r.DeploymentParameters.MutatingWebhookName.ValueString()
		} else {
			mutatingWebhookName = nil
		}
		namespace := new(string)
		if !r.DeploymentParameters.Namespace.IsUnknown() && !r.DeploymentParameters.Namespace.IsNull() {
			*namespace = r.DeploymentParameters.Namespace.ValueString()
		} else {
			namespace = nil
		}
		noProxy := new(string)
		if !r.DeploymentParameters.NoProxy.IsUnknown() && !r.DeploymentParameters.NoProxy.IsNull() {
			*noProxy = r.DeploymentParameters.NoProxy.ValueString()
		} else {
			noProxy = nil
		}
		timeoutSeconds := new(int)
		if !r.DeploymentParameters.TimeoutSeconds.IsUnknown() && !r.DeploymentParameters.TimeoutSeconds.IsNull() {
			*timeoutSeconds = int(r.DeploymentParameters.TimeoutSeconds.ValueInt64())
		} else {
			timeoutSeconds = nil
		}
		var trustedCaCerts []string = []string{}
		for _, trustedCaCertsItem := range r.DeploymentParameters.TrustedCaCerts {
			trustedCaCerts = append(trustedCaCerts, trustedCaCertsItem.ValueString())
		}
		trustedContainerRegistry := new(string)
		if !r.DeploymentParameters.TrustedContainerRegistry.IsUnknown() && !r.DeploymentParameters.TrustedContainerRegistry.IsNull() {
			*trustedContainerRegistry = r.DeploymentParameters.TrustedContainerRegistry.ValueString()
		} else {
			trustedContainerRegistry = nil
		}
		deploymentParameters = &shared.SystemsV1SystemDeploymentParameters{
			DenyOnOpaFail:            denyOnOpaFail,
			Discovery:                discovery,
			Extra:                    extra,
			HTTPProxy:                httpProxy,
			HTTPSProxy:               httpsProxy,
			KubernetesVersion:        kubernetesVersion,
			MutatingWebhookName:      mutatingWebhookName,
			Namespace:                namespace,
			NoProxy:                  noProxy,
			TimeoutSeconds:           timeoutSeconds,
			TrustedCaCerts:           trustedCaCerts,
			TrustedContainerRegistry: trustedContainerRegistry,
		}
	}
	description := new(string)
	if !r.Description.IsUnknown() && !r.Description.IsNull() {
		*description = r.Description.ValueString()
	} else {
		description = nil
	}
	errorSetting := new(string)
	if !r.ErrorSetting.IsUnknown() && !r.ErrorSetting.IsNull() {
		*errorSetting = r.ErrorSetting.ValueString()
	} else {
		errorSetting = nil
	}
	var externalBundles *shared.SystemsV1ExternalBundleConfig
	if r.ExternalBundles != nil {
		bundles := make(map[string]shared.SystemsV1OpaConfigBundleDeclaration)
		for bundlesKey, bundlesValue := range r.ExternalBundles.Bundles {
			persist := new(bool)
			if !bundlesValue.Persist.IsUnknown() && !bundlesValue.Persist.IsNull() {
				*persist = bundlesValue.Persist.ValueBool()
			} else {
				persist = nil
			}
			var polling *shared.SystemsV1PollingConfig
			if bundlesValue.Polling != nil {
				longPollingTimeoutSeconds := new(int64)
				if !bundlesValue.Polling.LongPollingTimeoutSeconds.IsUnknown() && !bundlesValue.Polling.LongPollingTimeoutSeconds.IsNull() {
					*longPollingTimeoutSeconds = bundlesValue.Polling.LongPollingTimeoutSeconds.ValueInt64()
				} else {
					longPollingTimeoutSeconds = nil
				}
				maxDelaySeconds := new(int64)
				if !bundlesValue.Polling.MaxDelaySeconds.IsUnknown() && !bundlesValue.Polling.MaxDelaySeconds.IsNull() {
					*maxDelaySeconds = bundlesValue.Polling.MaxDelaySeconds.ValueInt64()
				} else {
					maxDelaySeconds = nil
				}
				minDelaySeconds := new(int64)
				if !bundlesValue.Polling.MinDelaySeconds.IsUnknown() && !bundlesValue.Polling.MinDelaySeconds.IsNull() {
					*minDelaySeconds = bundlesValue.Polling.MinDelaySeconds.ValueInt64()
				} else {
					minDelaySeconds = nil
				}
				polling = &shared.SystemsV1PollingConfig{
					LongPollingTimeoutSeconds: longPollingTimeoutSeconds,
					MaxDelaySeconds:           maxDelaySeconds,
					MinDelaySeconds:           minDelaySeconds,
				}
			}
			resource := new(string)
			if !bundlesValue.Resource.IsUnknown() && !bundlesValue.Resource.IsNull() {
				*resource = bundlesValue.Resource.ValueString()
			} else {
				resource = nil
			}
			var service string
			service = bundlesValue.Service.ValueString()

			var signing *shared.SystemsV1VerificationConfig
			if bundlesValue.Signing != nil {
				var excludeFiles []string = []string{}
				for _, excludeFilesItem := range bundlesValue.Signing.ExcludeFiles {
					excludeFiles = append(excludeFiles, excludeFilesItem.ValueString())
				}
				keyid := new(string)
				if !bundlesValue.Signing.Keyid.IsUnknown() && !bundlesValue.Signing.Keyid.IsNull() {
					*keyid = bundlesValue.Signing.Keyid.ValueString()
				} else {
					keyid = nil
				}
				publicKeys := make(map[string]shared.SystemsV1KeyConfig)
				for publicKeysKey, publicKeysValue := range bundlesValue.Signing.PublicKeys {
					algorithm := new(string)
					if !publicKeysValue.Algorithm.IsUnknown() && !publicKeysValue.Algorithm.IsNull() {
						*algorithm = publicKeysValue.Algorithm.ValueString()
					} else {
						algorithm = nil
					}
					key1 := new(string)
					if !publicKeysValue.Key.IsUnknown() && !publicKeysValue.Key.IsNull() {
						*key1 = publicKeysValue.Key.ValueString()
					} else {
						key1 = nil
					}
					privateKey := new(string)
					if !publicKeysValue.PrivateKey.IsUnknown() && !publicKeysValue.PrivateKey.IsNull() {
						*privateKey = publicKeysValue.PrivateKey.ValueString()
					} else {
						privateKey = nil
					}
					scope := new(string)
					if !publicKeysValue.Scope.IsUnknown() && !publicKeysValue.Scope.IsNull() {
						*scope = publicKeysValue.Scope.ValueString()
					} else {
						scope = nil
					}
					publicKeysInst := shared.SystemsV1KeyConfig{
						Algorithm:  algorithm,
						Key:        key1,
						PrivateKey: privateKey,
						Scope:      scope,
					}
					publicKeys[publicKeysKey] = publicKeysInst
				}
				scope1 := new(string)
				if !bundlesValue.Signing.Scope.IsUnknown() && !bundlesValue.Signing.Scope.IsNull() {
					*scope1 = bundlesValue.Signing.Scope.ValueString()
				} else {
					scope1 = nil
				}
				signing = &shared.SystemsV1VerificationConfig{
					ExcludeFiles: excludeFiles,
					Keyid:        keyid,
					PublicKeys:   publicKeys,
					Scope:        scope1,
				}
			}
			sizeLimitBytes := new(int64)
			if !bundlesValue.SizeLimitBytes.IsUnknown() && !bundlesValue.SizeLimitBytes.IsNull() {
				*sizeLimitBytes = bundlesValue.SizeLimitBytes.ValueInt64()
			} else {
				sizeLimitBytes = nil
			}
			bundlesInst := shared.SystemsV1OpaConfigBundleDeclaration{
				Persist:        persist,
				Polling:        polling,
				Resource:       resource,
				Service:        service,
				Signing:        signing,
				SizeLimitBytes: sizeLimitBytes,
			}
			bundles[bundlesKey] = bundlesInst
		}
		var services []shared.SystemsV1OpaConfigServiceDeclaration = []shared.SystemsV1OpaConfigServiceDeclaration{}
		for _, servicesItem := range r.ExternalBundles.Services {
			allowInsecureTLS := new(bool)
			if !servicesItem.AllowInsecureTLS.IsUnknown() && !servicesItem.AllowInsecureTLS.IsNull() {
				*allowInsecureTLS = servicesItem.AllowInsecureTLS.ValueBool()
			} else {
				allowInsecureTLS = nil
			}
			var credentials *shared.SystemsV1OpaConfigServiceDeclarationCredentials
			if servicesItem.Credentials != nil {
				var azureManagedIdentity *shared.SystemsV1AzureManagedIdentitiesAuthPlugin
				if servicesItem.Credentials.AzureManagedIdentity != nil {
					var apiVersion string
					apiVersion = servicesItem.Credentials.AzureManagedIdentity.APIVersion.ValueString()

					var clientID string
					clientID = servicesItem.Credentials.AzureManagedIdentity.ClientID.ValueString()

					var endpoint1 string
					endpoint1 = servicesItem.Credentials.AzureManagedIdentity.Endpoint.ValueString()

					var miResID string
					miResID = servicesItem.Credentials.AzureManagedIdentity.MiResID.ValueString()

					var objectID string
					objectID = servicesItem.Credentials.AzureManagedIdentity.ObjectID.ValueString()

					var resource1 string
					resource1 = servicesItem.Credentials.AzureManagedIdentity.Resource.ValueString()

					azureManagedIdentity = &shared.SystemsV1AzureManagedIdentitiesAuthPlugin{
						APIVersion: apiVersion,
						ClientID:   clientID,
						Endpoint:   endpoint1,
						MiResID:    miResID,
						ObjectID:   objectID,
						Resource:   resource1,
					}
				}
				var bearer *shared.SystemsV1BearerAuthPlugin
				if servicesItem.Credentials.Bearer != nil {
					scheme := new(string)
					if !servicesItem.Credentials.Bearer.Scheme.IsUnknown() && !servicesItem.Credentials.Bearer.Scheme.IsNull() {
						*scheme = servicesItem.Credentials.Bearer.Scheme.ValueString()
					} else {
						scheme = nil
					}
					var token string
					token = servicesItem.Credentials.Bearer.Token.ValueString()

					var tokenPath string
					tokenPath = servicesItem.Credentials.Bearer.TokenPath.ValueString()

					bearer = &shared.SystemsV1BearerAuthPlugin{
						Scheme:    scheme,
						Token:     token,
						TokenPath: tokenPath,
					}
				}
				var clientTLS *shared.SystemsV1ClientTLSAuthPlugin
				if servicesItem.Credentials.ClientTLS != nil {
					var cert string
					cert = servicesItem.Credentials.ClientTLS.Cert.ValueString()

					var privateKey1 string
					privateKey1 = servicesItem.Credentials.ClientTLS.PrivateKey.ValueString()

					privateKeyPassphrase := new(string)
					if !servicesItem.Credentials.ClientTLS.PrivateKeyPassphrase.IsUnknown() && !servicesItem.Credentials.ClientTLS.PrivateKeyPassphrase.IsNull() {
						*privateKeyPassphrase = servicesItem.Credentials.ClientTLS.PrivateKeyPassphrase.ValueString()
					} else {
						privateKeyPassphrase = nil
					}
					clientTLS = &shared.SystemsV1ClientTLSAuthPlugin{
						Cert:                 cert,
						PrivateKey:           privateKey1,
						PrivateKeyPassphrase: privateKeyPassphrase,
					}
				}
				var gcpMetadata *shared.SystemsV1GcpMetadataAuthPlugin
				if servicesItem.Credentials.GcpMetadata != nil {
					var accessTokenPath string
					accessTokenPath = servicesItem.Credentials.GcpMetadata.AccessTokenPath.ValueString()

					var audience string
					audience = servicesItem.Credentials.GcpMetadata.Audience.ValueString()

					var endpoint2 string
					endpoint2 = servicesItem.Credentials.GcpMetadata.Endpoint.ValueString()

					var idTokenPath string
					idTokenPath = servicesItem.Credentials.GcpMetadata.IDTokenPath.ValueString()

					var scopes []string = []string{}
					for _, scopesItem := range servicesItem.Credentials.GcpMetadata.Scopes {
						scopes = append(scopes, scopesItem.ValueString())
					}
					gcpMetadata = &shared.SystemsV1GcpMetadataAuthPlugin{
						AccessTokenPath: accessTokenPath,
						Audience:        audience,
						Endpoint:        endpoint2,
						IDTokenPath:     idTokenPath,
						Scopes:          scopes,
					}
				}
				var oauth2 *shared.SystemsV1Oauth2ClientCredentialsAuthPlugin
				if servicesItem.Credentials.Oauth2 != nil {
					additionalClaims := shared.AdditionalClaims{}
					additionalHeaders := make(map[string]string)
					for additionalHeadersKey, additionalHeadersValue := range servicesItem.Credentials.Oauth2.AdditionalHeaders {
						var additionalHeadersInst string
						additionalHeadersInst = additionalHeadersValue.ValueString()

						additionalHeaders[additionalHeadersKey] = additionalHeadersInst
					}
					additionalParameters := make(map[string]string)
					for additionalParametersKey, additionalParametersValue := range servicesItem.Credentials.Oauth2.AdditionalParameters {
						var additionalParametersInst string
						additionalParametersInst = additionalParametersValue.ValueString()

						additionalParameters[additionalParametersKey] = additionalParametersInst
					}
					var clientId1 string
					clientId1 = servicesItem.Credentials.Oauth2.ClientID.ValueString()

					var clientSecret string
					clientSecret = servicesItem.Credentials.Oauth2.ClientSecret.ValueString()

					var grantType string
					grantType = servicesItem.Credentials.Oauth2.GrantType.ValueString()

					var includeJtiClaim bool
					includeJtiClaim = servicesItem.Credentials.Oauth2.IncludeJtiClaim.ValueBool()

					var scopes1 []string = []string{}
					for _, scopesItem1 := range servicesItem.Credentials.Oauth2.Scopes {
						scopes1 = append(scopes1, scopesItem1.ValueString())
					}
					var signingKey string
					signingKey = servicesItem.Credentials.Oauth2.SigningKey.ValueString()

					var thumbprint string
					thumbprint = servicesItem.Credentials.Oauth2.Thumbprint.ValueString()

					var tokenURL string
					tokenURL = servicesItem.Credentials.Oauth2.TokenURL.ValueString()

					oauth2 = &shared.SystemsV1Oauth2ClientCredentialsAuthPlugin{
						AdditionalClaims:     additionalClaims,
						AdditionalHeaders:    additionalHeaders,
						AdditionalParameters: additionalParameters,
						ClientID:             clientId1,
						ClientSecret:         clientSecret,
						GrantType:            grantType,
						IncludeJtiClaim:      includeJtiClaim,
						Scopes:               scopes1,
						SigningKey:           signingKey,
						Thumbprint:           thumbprint,
						TokenURL:             tokenURL,
					}
				}
				plugin := new(string)
				if !servicesItem.Credentials.Plugin.IsUnknown() && !servicesItem.Credentials.Plugin.IsNull() {
					*plugin = servicesItem.Credentials.Plugin.ValueString()
				} else {
					plugin = nil
				}
				var s3Signing *shared.SystemsV1AwsSigningAuthPlugin
				if servicesItem.Credentials.S3Signing != nil {
					var environmentCredentials1 interface{}
					if !servicesItem.Credentials.S3Signing.EnvironmentCredentials.IsUnknown() && !servicesItem.Credentials.S3Signing.EnvironmentCredentials.IsNull() {
						_ = json.Unmarshal([]byte(servicesItem.Credentials.S3Signing.EnvironmentCredentials.ValueString()), &environmentCredentials1)
					}
					var metadataCredentials1 *shared.SystemsV1AwsMetadataCredentialService
					if servicesItem.Credentials.S3Signing.MetadataCredentials != nil {
						var awsRegion2 string
						awsRegion2 = servicesItem.Credentials.S3Signing.MetadataCredentials.AwsRegion.ValueString()

						iamRole1 := new(string)
						if !servicesItem.Credentials.S3Signing.MetadataCredentials.IamRole.IsUnknown() && !servicesItem.Credentials.S3Signing.MetadataCredentials.IamRole.IsNull() {
							*iamRole1 = servicesItem.Credentials.S3Signing.MetadataCredentials.IamRole.ValueString()
						} else {
							iamRole1 = nil
						}
						metadataCredentials1 = &shared.SystemsV1AwsMetadataCredentialService{
							AwsRegion: awsRegion2,
							IamRole:   iamRole1,
						}
					}
					var profileCredentials *shared.SystemsV1AwsProfileCredentialService
					if servicesItem.Credentials.S3Signing.ProfileCredentials != nil {
						var awsRegion3 string
						awsRegion3 = servicesItem.Credentials.S3Signing.ProfileCredentials.AwsRegion.ValueString()

						path3 := new(string)
						if !servicesItem.Credentials.S3Signing.ProfileCredentials.Path.IsUnknown() && !servicesItem.Credentials.S3Signing.ProfileCredentials.Path.IsNull() {
							*path3 = servicesItem.Credentials.S3Signing.ProfileCredentials.Path.ValueString()
						} else {
							path3 = nil
						}
						profile := new(string)
						if !servicesItem.Credentials.S3Signing.ProfileCredentials.Profile.IsUnknown() && !servicesItem.Credentials.S3Signing.ProfileCredentials.Profile.IsNull() {
							*profile = servicesItem.Credentials.S3Signing.ProfileCredentials.Profile.ValueString()
						} else {
							profile = nil
						}
						profileCredentials = &shared.SystemsV1AwsProfileCredentialService{
							AwsRegion: awsRegion3,
							Path:      path3,
							Profile:   profile,
						}
					}
					service1 := new(string)
					if !servicesItem.Credentials.S3Signing.Service.IsUnknown() && !servicesItem.Credentials.S3Signing.Service.IsNull() {
						*service1 = servicesItem.Credentials.S3Signing.Service.ValueString()
					} else {
						service1 = nil
					}
					var webIdentityCredentials1 *shared.SystemsV1AwsWebIdentityCredentialService
					if servicesItem.Credentials.S3Signing.WebIdentityCredentials != nil {
						var awsRegion4 string
						awsRegion4 = servicesItem.Credentials.S3Signing.WebIdentityCredentials.AwsRegion.ValueString()

						var sessionName1 string
						sessionName1 = servicesItem.Credentials.S3Signing.WebIdentityCredentials.SessionName.ValueString()

						webIdentityCredentials1 = &shared.SystemsV1AwsWebIdentityCredentialService{
							AwsRegion:   awsRegion4,
							SessionName: sessionName1,
						}
					}
					s3Signing = &shared.SystemsV1AwsSigningAuthPlugin{
						EnvironmentCredentials: environmentCredentials1,
						MetadataCredentials:    metadataCredentials1,
						ProfileCredentials:     profileCredentials,
						Service:                service1,
						WebIdentityCredentials: webIdentityCredentials1,
					}
				}
				credentials = &shared.SystemsV1OpaConfigServiceDeclarationCredentials{
					AzureManagedIdentity: azureManagedIdentity,
					Bearer:               bearer,
					ClientTLS:            clientTLS,
					GcpMetadata:          gcpMetadata,
					Oauth2:               oauth2,
					Plugin:               plugin,
					S3Signing:            s3Signing,
				}
			}
			headers := make(map[string]string)
			for headersKey, headersValue := range servicesItem.Headers {
				var headersInst string
				headersInst = headersValue.ValueString()

				headers[headersKey] = headersInst
			}
			keys := make(map[string]shared.KeysConfig)
			for keysKey, keysValue := range servicesItem.Keys {
				var algorithm1 string
				algorithm1 = keysValue.Algorithm.ValueString()

				var key2 string
				key2 = keysValue.Key.ValueString()

				var privateKey2 string
				privateKey2 = keysValue.PrivateKey.ValueString()

				var scope2 string
				scope2 = keysValue.Scope.ValueString()

				keysInst := shared.KeysConfig{
					Algorithm:  algorithm1,
					Key:        key2,
					PrivateKey: privateKey2,
					Scope:      scope2,
				}
				keys[keysKey] = keysInst
			}
			var name string
			name = servicesItem.Name.ValueString()

			responseHeaderTimeoutSeconds := new(int64)
			if !servicesItem.ResponseHeaderTimeoutSeconds.IsUnknown() && !servicesItem.ResponseHeaderTimeoutSeconds.IsNull() {
				*responseHeaderTimeoutSeconds = servicesItem.ResponseHeaderTimeoutSeconds.ValueInt64()
			} else {
				responseHeaderTimeoutSeconds = nil
			}
			var tls *shared.SystemsV1ServerTLSConfig
			if servicesItem.TLS != nil {
				caCert := new(string)
				if !servicesItem.TLS.CaCert.IsUnknown() && !servicesItem.TLS.CaCert.IsNull() {
					*caCert = servicesItem.TLS.CaCert.ValueString()
				} else {
					caCert = nil
				}
				systemCaRequired := new(bool)
				if !servicesItem.TLS.SystemCaRequired.IsUnknown() && !servicesItem.TLS.SystemCaRequired.IsNull() {
					*systemCaRequired = servicesItem.TLS.SystemCaRequired.ValueBool()
				} else {
					systemCaRequired = nil
				}
				tls = &shared.SystemsV1ServerTLSConfig{
					CaCert:           caCert,
					SystemCaRequired: systemCaRequired,
				}
			}
			type1 := new(string)
			if !servicesItem.Type.IsUnknown() && !servicesItem.Type.IsNull() {
				*type1 = servicesItem.Type.ValueString()
			} else {
				type1 = nil
			}
			var url string
			url = servicesItem.URL.ValueString()

			services = append(services, shared.SystemsV1OpaConfigServiceDeclaration{
				AllowInsecureTLS:             allowInsecureTLS,
				Credentials:                  credentials,
				Headers:                      headers,
				Keys:                         keys,
				Name:                         name,
				ResponseHeaderTimeoutSeconds: responseHeaderTimeoutSeconds,
				TLS:                          tls,
				Type:                         type1,
				URL:                          url,
			})
		}
		externalBundles = &shared.SystemsV1ExternalBundleConfig{
			Bundles:  bundles,
			Services: services,
		}
	}
	externalID := new(string)
	if !r.ExternalID.IsUnknown() && !r.ExternalID.IsNull() {
		*externalID = r.ExternalID.ValueString()
	} else {
		externalID = nil
	}
	filterStacks := new(bool)
	if !r.FilterStacks.IsUnknown() && !r.FilterStacks.IsNull() {
		*filterStacks = r.FilterStacks.ValueBool()
	} else {
		filterStacks = nil
	}
	kafkaTopic := new(string)
	if !r.KafkaTopic.IsUnknown() && !r.KafkaTopic.IsNull() {
		*kafkaTopic = r.KafkaTopic.ValueString()
	} else {
		kafkaTopic = nil
	}
	mockOpaEnabled := new(bool)
	if !r.MockOpaEnabled.IsUnknown() && !r.MockOpaEnabled.IsNull() {
		*mockOpaEnabled = r.MockOpaEnabled.ValueBool()
	} else {
		mockOpaEnabled = nil
	}
	var name1 string
	name1 = r.Name.ValueString()

	readOnly := new(bool)
	if !r.ReadOnly.IsUnknown() && !r.ReadOnly.IsNull() {
		*readOnly = r.ReadOnly.ValueBool()
	} else {
		readOnly = nil
	}
	var sourceControl *shared.GitV1SourceControlConfig
	if r.SourceControl != nil {
		var commit string
		commit = r.SourceControl.Origin.Commit.ValueString()

		var credentials1 string
		credentials1 = r.SourceControl.Origin.Credentials.ValueString()

		var path4 string
		path4 = r.SourceControl.Origin.Path.ValueString()

		var reference string
		reference = r.SourceControl.Origin.Reference.ValueString()

		var sshCredentials *shared.GitV1SSHCredentials
		if r.SourceControl.Origin.SSHCredentials != nil {
			var passphrase string
			passphrase = r.SourceControl.Origin.SSHCredentials.Passphrase.ValueString()

			var privateKey3 string
			privateKey3 = r.SourceControl.Origin.SSHCredentials.PrivateKey.ValueString()

			sshCredentials = &shared.GitV1SSHCredentials{
				Passphrase: passphrase,
				PrivateKey: privateKey3,
			}
		}
		var url1 string
		url1 = r.SourceControl.Origin.URL.ValueString()

		origin := shared.GitV1GitRepoConfig{
			Commit:         commit,
			Credentials:    credentials1,
			Path:           path4,
			Reference:      reference,
			SSHCredentials: sshCredentials,
			URL:            url1,
		}
		sourceControl = &shared.GitV1SourceControlConfig{
			Origin: origin,
		}
	}
	var typeVar1 string
	typeVar1 = r.Type.ValueString()

	var typeParameters *shared.SystemsV1SystemsPutRequestTypeParameters
	if r.TypeParameters != nil {
		typeParameters = &shared.SystemsV1SystemsPutRequestTypeParameters{}
	}
	out := shared.SystemsV1SystemsPutRequest{
		BundleDownload:        bundleDownload,
		BundleRegistry:        bundleRegistry,
		ContextBundleDataOnly: contextBundleDataOnly,
		ContextBundleRoots:    contextBundleRoots,
		DecisionMappings:      decisionMappings,
		DeploymentParameters:  deploymentParameters,
		Description:           description,
		ErrorSetting:          errorSetting,
		ExternalBundles:       externalBundles,
		ExternalID:            externalID,
		FilterStacks:          filterStacks,
		KafkaTopic:            kafkaTopic,
		MockOpaEnabled:        mockOpaEnabled,
		Name:                  name1,
		ReadOnly:              readOnly,
		SourceControl:         sourceControl,
		Type:                  typeVar1,
		TypeParameters:        typeParameters,
	}
	return &out
}
