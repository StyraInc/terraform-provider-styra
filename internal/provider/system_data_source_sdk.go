// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"encoding/json"
	tfTypes "github.com/StyraInc/terraform-provider-styra/internal/provider/types"
	"github.com/StyraInc/terraform-provider-styra/internal/sdk/models/shared"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"time"
)

func (r *SystemDataSourceModel) RefreshFromSharedSystemsV1SystemsGetResponse(resp *shared.SystemsV1SystemsGetResponse) {
	if resp != nil {
		r.RequestID = types.StringPointerValue(resp.RequestID)
		r.Result.Authz.RoleBindings = []tfTypes.SystemsV1V1RoleBindingConfig{}
		if len(r.Result.Authz.RoleBindings) > len(resp.Result.Authz.RoleBindings) {
			r.Result.Authz.RoleBindings = r.Result.Authz.RoleBindings[:len(resp.Result.Authz.RoleBindings)]
		}
		for roleBindingsCount, roleBindingsItem := range resp.Result.Authz.RoleBindings {
			var roleBindings1 tfTypes.SystemsV1V1RoleBindingConfig
			roleBindings1.ID = types.StringValue(roleBindingsItem.ID)
			roleBindings1.RoleName = types.StringValue(roleBindingsItem.RoleName)
			if roleBindingsCount+1 > len(r.Result.Authz.RoleBindings) {
				r.Result.Authz.RoleBindings = append(r.Result.Authz.RoleBindings, roleBindings1)
			} else {
				r.Result.Authz.RoleBindings[roleBindingsCount].ID = roleBindings1.ID
				r.Result.Authz.RoleBindings[roleBindingsCount].RoleName = roleBindings1.RoleName
			}
		}
		if resp.Result.BundleDownload == nil {
			r.Result.BundleDownload = nil
		} else {
			r.Result.BundleDownload = &tfTypes.SystemsV1BundleDownloadConfig{}
			r.Result.BundleDownload.DeltaBundles = types.BoolPointerValue(resp.Result.BundleDownload.DeltaBundles)
		}
		if resp.Result.BundleRegistry == nil {
			r.Result.BundleRegistry = nil
		} else {
			r.Result.BundleRegistry = &tfTypes.SystemsV1BundleRegistryConfig{}
			r.Result.BundleRegistry.DisableBundleCompatibilityCheck = types.BoolPointerValue(resp.Result.BundleRegistry.DisableBundleCompatibilityCheck)
			if resp.Result.BundleRegistry.DistributionS3 == nil {
				r.Result.BundleRegistry.DistributionS3 = nil
			} else {
				r.Result.BundleRegistry.DistributionS3 = &tfTypes.SystemsV1BundleDistributionS3Config{}
				r.Result.BundleRegistry.DistributionS3.AccessKeys = types.StringPointerValue(resp.Result.BundleRegistry.DistributionS3.AccessKeys)
				r.Result.BundleRegistry.DistributionS3.Bucket = types.StringValue(resp.Result.BundleRegistry.DistributionS3.Bucket)
				r.Result.BundleRegistry.DistributionS3.ContextPath = types.StringPointerValue(resp.Result.BundleRegistry.DistributionS3.ContextPath)
				r.Result.BundleRegistry.DistributionS3.DiscoveryPath = types.StringPointerValue(resp.Result.BundleRegistry.DistributionS3.DiscoveryPath)
				r.Result.BundleRegistry.DistributionS3.Endpoint = types.StringPointerValue(resp.Result.BundleRegistry.DistributionS3.Endpoint)
				if resp.Result.BundleRegistry.DistributionS3.OpaCredentials == nil {
					r.Result.BundleRegistry.DistributionS3.OpaCredentials = nil
				} else {
					r.Result.BundleRegistry.DistributionS3.OpaCredentials = &tfTypes.SystemsV1BundleDistributionS3ConfigOpaCredentials{}
					if resp.Result.BundleRegistry.DistributionS3.OpaCredentials.EnvironmentCredentials == nil {
						r.Result.BundleRegistry.DistributionS3.OpaCredentials.EnvironmentCredentials = nil
					} else {
						r.Result.BundleRegistry.DistributionS3.OpaCredentials.EnvironmentCredentials = &tfTypes.TypeParameters{}
					}
					if resp.Result.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials == nil {
						r.Result.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials = nil
					} else {
						r.Result.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials = &tfTypes.SystemsV1BundleDistributionS3ConfigOpaCredentialsMetadataCredentials{}
						r.Result.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials.AwsRegion = types.StringValue(resp.Result.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials.AwsRegion)
						r.Result.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials.IamRole = types.StringPointerValue(resp.Result.BundleRegistry.DistributionS3.OpaCredentials.MetadataCredentials.IamRole)
					}
					if resp.Result.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials == nil {
						r.Result.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials = nil
					} else {
						r.Result.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials = &tfTypes.SystemsV1BundleDistributionS3ConfigOpaCredentialsWebIdentityCredentials{}
						r.Result.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials.AwsRegion = types.StringValue(resp.Result.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials.AwsRegion)
						r.Result.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials.SessionName = types.StringValue(resp.Result.BundleRegistry.DistributionS3.OpaCredentials.WebIdentityCredentials.SessionName)
					}
				}
				r.Result.BundleRegistry.DistributionS3.PolicyPath = types.StringPointerValue(resp.Result.BundleRegistry.DistributionS3.PolicyPath)
				r.Result.BundleRegistry.DistributionS3.Region = types.StringValue(resp.Result.BundleRegistry.DistributionS3.Region)
				r.Result.BundleRegistry.DistributionS3.RoleArn = types.StringPointerValue(resp.Result.BundleRegistry.DistributionS3.RoleArn)
			}
			r.Result.BundleRegistry.Entrypoints = []types.String{}
			for _, v := range resp.Result.BundleRegistry.Entrypoints {
				r.Result.BundleRegistry.Entrypoints = append(r.Result.BundleRegistry.Entrypoints, types.StringValue(v))
			}
			r.Result.BundleRegistry.ManualDeployment = types.BoolPointerValue(resp.Result.BundleRegistry.ManualDeployment)
			if len(resp.Result.BundleRegistry.ManualDeploymentOverrides) > 0 {
				r.Result.BundleRegistry.ManualDeploymentOverrides = make(map[string]types.Bool)
				for key, value := range resp.Result.BundleRegistry.ManualDeploymentOverrides {
					r.Result.BundleRegistry.ManualDeploymentOverrides[key] = types.BoolValue(value)
				}
			}
			r.Result.BundleRegistry.MaxBundles = types.Int64PointerValue(resp.Result.BundleRegistry.MaxBundles)
			r.Result.BundleRegistry.MaxDeployedBundles = types.Int64PointerValue(resp.Result.BundleRegistry.MaxDeployedBundles)
			if resp.Result.BundleRegistry.OptimizationLevel != nil {
				r.Result.BundleRegistry.OptimizationLevel = types.Int64Value(int64(*resp.Result.BundleRegistry.OptimizationLevel))
			} else {
				r.Result.BundleRegistry.OptimizationLevel = types.Int64Null()
			}
		}
		r.Result.ContextBundleDataOnly = types.BoolPointerValue(resp.Result.ContextBundleDataOnly)
		r.Result.ContextBundleRoots = []types.String{}
		for _, v := range resp.Result.ContextBundleRoots {
			r.Result.ContextBundleRoots = append(r.Result.ContextBundleRoots, types.StringValue(v))
		}
		r.Result.Datasources = []tfTypes.SystemsV1DatasourceConfig{}
		if len(r.Result.Datasources) > len(resp.Result.Datasources) {
			r.Result.Datasources = r.Result.Datasources[:len(resp.Result.Datasources)]
		}
		for datasourcesCount, datasourcesItem := range resp.Result.Datasources {
			var datasources1 tfTypes.SystemsV1DatasourceConfig
			datasources1.Category = types.StringValue(datasourcesItem.Category)
			datasources1.ID = types.StringValue(datasourcesItem.ID)
			datasources1.Optional = types.BoolPointerValue(datasourcesItem.Optional)
			if datasourcesItem.Status == nil {
				datasources1.Status = nil
			} else {
				datasources1.Status = &tfTypes.MetaV1Status{}
				datasources1.Status.Code = types.StringValue(datasourcesItem.Status.Code)
				datasources1.Status.Message = types.StringValue(datasourcesItem.Status.Message)
				datasources1.Status.Timestamp = types.StringValue(datasourcesItem.Status.Timestamp.Format(time.RFC3339Nano))
			}
			if datasourcesCount+1 > len(r.Result.Datasources) {
				r.Result.Datasources = append(r.Result.Datasources, datasources1)
			} else {
				r.Result.Datasources[datasourcesCount].Category = datasources1.Category
				r.Result.Datasources[datasourcesCount].ID = datasources1.ID
				r.Result.Datasources[datasourcesCount].Optional = datasources1.Optional
				r.Result.Datasources[datasourcesCount].Status = datasources1.Status
			}
		}
		if len(resp.Result.DecisionMappings) > 0 {
			r.Result.DecisionMappings = make(map[string]tfTypes.SystemsV1RuleDecisionMappings)
			for systemsV1RuleDecisionMappingsKey, systemsV1RuleDecisionMappingsValue := range resp.Result.DecisionMappings {
				var systemsV1RuleDecisionMappingsResult tfTypes.SystemsV1RuleDecisionMappings
				if systemsV1RuleDecisionMappingsValue.Allowed == nil {
					systemsV1RuleDecisionMappingsResult.Allowed = nil
				} else {
					systemsV1RuleDecisionMappingsResult.Allowed = &tfTypes.SystemsV1AllowedMapping{}
					if systemsV1RuleDecisionMappingsValue.Allowed.Expected == nil {
						systemsV1RuleDecisionMappingsResult.Allowed.Expected = types.StringNull()
					} else {
						expectedResult, _ := json.Marshal(systemsV1RuleDecisionMappingsValue.Allowed.Expected)
						systemsV1RuleDecisionMappingsResult.Allowed.Expected = types.StringValue(string(expectedResult))
					}
					systemsV1RuleDecisionMappingsResult.Allowed.Negated = types.BoolPointerValue(systemsV1RuleDecisionMappingsValue.Allowed.Negated)
					systemsV1RuleDecisionMappingsResult.Allowed.Path = types.StringValue(systemsV1RuleDecisionMappingsValue.Allowed.Path)
				}
				systemsV1RuleDecisionMappingsResult.Columns = []tfTypes.SystemsV1ColumnMapping{}
				for columnsCount, columnsItem := range systemsV1RuleDecisionMappingsValue.Columns {
					var columns1 tfTypes.SystemsV1ColumnMapping
					columns1.Key = types.StringValue(columnsItem.Key)
					columns1.Path = types.StringValue(columnsItem.Path)
					columns1.Type = types.StringPointerValue(columnsItem.Type)
					if columnsCount+1 > len(systemsV1RuleDecisionMappingsResult.Columns) {
						systemsV1RuleDecisionMappingsResult.Columns = append(systemsV1RuleDecisionMappingsResult.Columns, columns1)
					} else {
						systemsV1RuleDecisionMappingsResult.Columns[columnsCount].Key = columns1.Key
						systemsV1RuleDecisionMappingsResult.Columns[columnsCount].Path = columns1.Path
						systemsV1RuleDecisionMappingsResult.Columns[columnsCount].Type = columns1.Type
					}
				}
				if systemsV1RuleDecisionMappingsValue.Reason == nil {
					systemsV1RuleDecisionMappingsResult.Reason = nil
				} else {
					systemsV1RuleDecisionMappingsResult.Reason = &tfTypes.SystemsV1ReasonMapping{}
					systemsV1RuleDecisionMappingsResult.Reason.Path = types.StringValue(systemsV1RuleDecisionMappingsValue.Reason.Path)
				}
				r.Result.DecisionMappings[systemsV1RuleDecisionMappingsKey] = systemsV1RuleDecisionMappingsResult
			}
		}
		if resp.Result.DeploymentParameters == nil {
			r.Result.DeploymentParameters = nil
		} else {
			r.Result.DeploymentParameters = &tfTypes.SystemsV1SystemDeploymentParameters{}
			r.Result.DeploymentParameters.DenyOnOpaFail = types.BoolPointerValue(resp.Result.DeploymentParameters.DenyOnOpaFail)
			if resp.Result.DeploymentParameters.Discovery == nil {
				r.Result.DeploymentParameters.Discovery = nil
			} else {
				r.Result.DeploymentParameters.Discovery = &tfTypes.TypeParameters{}
			}
			if resp.Result.DeploymentParameters.Extra == nil {
				r.Result.DeploymentParameters.Extra = nil
			} else {
				r.Result.DeploymentParameters.Extra = &tfTypes.TypeParameters{}
			}
			r.Result.DeploymentParameters.HTTPProxy = types.StringPointerValue(resp.Result.DeploymentParameters.HTTPProxy)
			r.Result.DeploymentParameters.HTTPSProxy = types.StringPointerValue(resp.Result.DeploymentParameters.HTTPSProxy)
			r.Result.DeploymentParameters.KubernetesVersion = types.StringPointerValue(resp.Result.DeploymentParameters.KubernetesVersion)
			r.Result.DeploymentParameters.MutatingWebhookName = types.StringPointerValue(resp.Result.DeploymentParameters.MutatingWebhookName)
			r.Result.DeploymentParameters.Namespace = types.StringPointerValue(resp.Result.DeploymentParameters.Namespace)
			r.Result.DeploymentParameters.NoProxy = types.StringPointerValue(resp.Result.DeploymentParameters.NoProxy)
			if resp.Result.DeploymentParameters.TimeoutSeconds != nil {
				r.Result.DeploymentParameters.TimeoutSeconds = types.Int64Value(int64(*resp.Result.DeploymentParameters.TimeoutSeconds))
			} else {
				r.Result.DeploymentParameters.TimeoutSeconds = types.Int64Null()
			}
			r.Result.DeploymentParameters.TrustedCaCerts = []types.String{}
			for _, v := range resp.Result.DeploymentParameters.TrustedCaCerts {
				r.Result.DeploymentParameters.TrustedCaCerts = append(r.Result.DeploymentParameters.TrustedCaCerts, types.StringValue(v))
			}
			r.Result.DeploymentParameters.TrustedContainerRegistry = types.StringPointerValue(resp.Result.DeploymentParameters.TrustedContainerRegistry)
		}
		r.Result.Description = types.StringPointerValue(resp.Result.Description)
		r.Result.ErrorSetting = types.StringPointerValue(resp.Result.ErrorSetting)
		if len(resp.Result.Errors) > 0 {
			r.Result.Errors = make(map[string]tfTypes.SystemsV1AgentErrors)
			for systemsV1AgentErrorsKey, systemsV1AgentErrorsValue := range resp.Result.Errors {
				var systemsV1AgentErrorsResult tfTypes.SystemsV1AgentErrors
				systemsV1AgentErrorsResult.Errors = []tfTypes.MetaV1Status{}
				for errorsCount, errorsItem := range systemsV1AgentErrorsValue.Errors {
					var errors2 tfTypes.MetaV1Status
					errors2.Code = types.StringValue(errorsItem.Code)
					errors2.Message = types.StringValue(errorsItem.Message)
					errors2.Timestamp = types.StringValue(errorsItem.Timestamp.Format(time.RFC3339Nano))
					if errorsCount+1 > len(systemsV1AgentErrorsResult.Errors) {
						systemsV1AgentErrorsResult.Errors = append(systemsV1AgentErrorsResult.Errors, errors2)
					} else {
						systemsV1AgentErrorsResult.Errors[errorsCount].Code = errors2.Code
						systemsV1AgentErrorsResult.Errors[errorsCount].Message = errors2.Message
						systemsV1AgentErrorsResult.Errors[errorsCount].Timestamp = errors2.Timestamp
					}
				}
				systemsV1AgentErrorsResult.Waiting = types.BoolValue(systemsV1AgentErrorsValue.Waiting)
				r.Result.Errors[systemsV1AgentErrorsKey] = systemsV1AgentErrorsResult
			}
		}
		if resp.Result.ExternalBundles == nil {
			r.Result.ExternalBundles = nil
		} else {
			r.Result.ExternalBundles = &tfTypes.SystemsV1ExternalBundleConfig{}
			if len(resp.Result.ExternalBundles.Bundles) > 0 {
				r.Result.ExternalBundles.Bundles = make(map[string]tfTypes.SystemsV1OpaConfigBundleDeclaration)
				for systemsV1OpaConfigBundleDeclarationKey, systemsV1OpaConfigBundleDeclarationValue := range resp.Result.ExternalBundles.Bundles {
					var systemsV1OpaConfigBundleDeclarationResult tfTypes.SystemsV1OpaConfigBundleDeclaration
					systemsV1OpaConfigBundleDeclarationResult.Persist = types.BoolPointerValue(systemsV1OpaConfigBundleDeclarationValue.Persist)
					if systemsV1OpaConfigBundleDeclarationValue.Polling == nil {
						systemsV1OpaConfigBundleDeclarationResult.Polling = nil
					} else {
						systemsV1OpaConfigBundleDeclarationResult.Polling = &tfTypes.SystemsV1PollingConfig{}
						systemsV1OpaConfigBundleDeclarationResult.Polling.LongPollingTimeoutSeconds = types.Int64PointerValue(systemsV1OpaConfigBundleDeclarationValue.Polling.LongPollingTimeoutSeconds)
						systemsV1OpaConfigBundleDeclarationResult.Polling.MaxDelaySeconds = types.Int64PointerValue(systemsV1OpaConfigBundleDeclarationValue.Polling.MaxDelaySeconds)
						systemsV1OpaConfigBundleDeclarationResult.Polling.MinDelaySeconds = types.Int64PointerValue(systemsV1OpaConfigBundleDeclarationValue.Polling.MinDelaySeconds)
					}
					systemsV1OpaConfigBundleDeclarationResult.Resource = types.StringPointerValue(systemsV1OpaConfigBundleDeclarationValue.Resource)
					systemsV1OpaConfigBundleDeclarationResult.Service = types.StringValue(systemsV1OpaConfigBundleDeclarationValue.Service)
					if systemsV1OpaConfigBundleDeclarationValue.Signing == nil {
						systemsV1OpaConfigBundleDeclarationResult.Signing = nil
					} else {
						systemsV1OpaConfigBundleDeclarationResult.Signing = &tfTypes.SystemsV1VerificationConfig{}
						systemsV1OpaConfigBundleDeclarationResult.Signing.ExcludeFiles = []types.String{}
						for _, v := range systemsV1OpaConfigBundleDeclarationValue.Signing.ExcludeFiles {
							systemsV1OpaConfigBundleDeclarationResult.Signing.ExcludeFiles = append(systemsV1OpaConfigBundleDeclarationResult.Signing.ExcludeFiles, types.StringValue(v))
						}
						systemsV1OpaConfigBundleDeclarationResult.Signing.Keyid = types.StringPointerValue(systemsV1OpaConfigBundleDeclarationValue.Signing.Keyid)
						if len(systemsV1OpaConfigBundleDeclarationValue.Signing.PublicKeys) > 0 {
							systemsV1OpaConfigBundleDeclarationResult.Signing.PublicKeys = make(map[string]tfTypes.SystemsV1KeyConfig)
							for systemsV1KeyConfigKey, systemsV1KeyConfigValue := range systemsV1OpaConfigBundleDeclarationValue.Signing.PublicKeys {
								var systemsV1KeyConfigResult tfTypes.SystemsV1KeyConfig
								systemsV1KeyConfigResult.Algorithm = types.StringPointerValue(systemsV1KeyConfigValue.Algorithm)
								systemsV1KeyConfigResult.Key = types.StringPointerValue(systemsV1KeyConfigValue.Key)
								systemsV1KeyConfigResult.PrivateKey = types.StringPointerValue(systemsV1KeyConfigValue.PrivateKey)
								systemsV1KeyConfigResult.Scope = types.StringPointerValue(systemsV1KeyConfigValue.Scope)
								systemsV1OpaConfigBundleDeclarationResult.Signing.PublicKeys[systemsV1KeyConfigKey] = systemsV1KeyConfigResult
							}
						}
						systemsV1OpaConfigBundleDeclarationResult.Signing.Scope = types.StringPointerValue(systemsV1OpaConfigBundleDeclarationValue.Signing.Scope)
					}
					systemsV1OpaConfigBundleDeclarationResult.SizeLimitBytes = types.Int64PointerValue(systemsV1OpaConfigBundleDeclarationValue.SizeLimitBytes)
					r.Result.ExternalBundles.Bundles[systemsV1OpaConfigBundleDeclarationKey] = systemsV1OpaConfigBundleDeclarationResult
				}
			}
			r.Result.ExternalBundles.Services = []tfTypes.SystemsV1OpaConfigServiceDeclaration{}
			if len(r.Result.ExternalBundles.Services) > len(resp.Result.ExternalBundles.Services) {
				r.Result.ExternalBundles.Services = r.Result.ExternalBundles.Services[:len(resp.Result.ExternalBundles.Services)]
			}
			for servicesCount, servicesItem := range resp.Result.ExternalBundles.Services {
				var services1 tfTypes.SystemsV1OpaConfigServiceDeclaration
				services1.AllowInsecureTLS = types.BoolPointerValue(servicesItem.AllowInsecureTLS)
				if servicesItem.Credentials == nil {
					services1.Credentials = nil
				} else {
					services1.Credentials = &tfTypes.SystemsV1OpaConfigServiceDeclarationCredentials{}
					if servicesItem.Credentials.AzureManagedIdentity == nil {
						services1.Credentials.AzureManagedIdentity = nil
					} else {
						services1.Credentials.AzureManagedIdentity = &tfTypes.SystemsV1AzureManagedIdentitiesAuthPlugin{}
						services1.Credentials.AzureManagedIdentity.APIVersion = types.StringValue(servicesItem.Credentials.AzureManagedIdentity.APIVersion)
						services1.Credentials.AzureManagedIdentity.ClientID = types.StringValue(servicesItem.Credentials.AzureManagedIdentity.ClientID)
						services1.Credentials.AzureManagedIdentity.Endpoint = types.StringValue(servicesItem.Credentials.AzureManagedIdentity.Endpoint)
						services1.Credentials.AzureManagedIdentity.MiResID = types.StringValue(servicesItem.Credentials.AzureManagedIdentity.MiResID)
						services1.Credentials.AzureManagedIdentity.ObjectID = types.StringValue(servicesItem.Credentials.AzureManagedIdentity.ObjectID)
						services1.Credentials.AzureManagedIdentity.Resource = types.StringValue(servicesItem.Credentials.AzureManagedIdentity.Resource)
					}
					if servicesItem.Credentials.Bearer == nil {
						services1.Credentials.Bearer = nil
					} else {
						services1.Credentials.Bearer = &tfTypes.SystemsV1BearerAuthPlugin{}
						services1.Credentials.Bearer.Scheme = types.StringPointerValue(servicesItem.Credentials.Bearer.Scheme)
						services1.Credentials.Bearer.Token = types.StringValue(servicesItem.Credentials.Bearer.Token)
						services1.Credentials.Bearer.TokenPath = types.StringValue(servicesItem.Credentials.Bearer.TokenPath)
					}
					if servicesItem.Credentials.ClientTLS == nil {
						services1.Credentials.ClientTLS = nil
					} else {
						services1.Credentials.ClientTLS = &tfTypes.SystemsV1ClientTLSAuthPlugin{}
						services1.Credentials.ClientTLS.Cert = types.StringValue(servicesItem.Credentials.ClientTLS.Cert)
						services1.Credentials.ClientTLS.PrivateKey = types.StringValue(servicesItem.Credentials.ClientTLS.PrivateKey)
						services1.Credentials.ClientTLS.PrivateKeyPassphrase = types.StringPointerValue(servicesItem.Credentials.ClientTLS.PrivateKeyPassphrase)
					}
					if servicesItem.Credentials.GcpMetadata == nil {
						services1.Credentials.GcpMetadata = nil
					} else {
						services1.Credentials.GcpMetadata = &tfTypes.SystemsV1GcpMetadataAuthPlugin{}
						services1.Credentials.GcpMetadata.AccessTokenPath = types.StringValue(servicesItem.Credentials.GcpMetadata.AccessTokenPath)
						services1.Credentials.GcpMetadata.Audience = types.StringValue(servicesItem.Credentials.GcpMetadata.Audience)
						services1.Credentials.GcpMetadata.Endpoint = types.StringValue(servicesItem.Credentials.GcpMetadata.Endpoint)
						services1.Credentials.GcpMetadata.IDTokenPath = types.StringValue(servicesItem.Credentials.GcpMetadata.IDTokenPath)
						services1.Credentials.GcpMetadata.Scopes = []types.String{}
						for _, v := range servicesItem.Credentials.GcpMetadata.Scopes {
							services1.Credentials.GcpMetadata.Scopes = append(services1.Credentials.GcpMetadata.Scopes, types.StringValue(v))
						}
					}
					if servicesItem.Credentials.Oauth2 == nil {
						services1.Credentials.Oauth2 = nil
					} else {
						services1.Credentials.Oauth2 = &tfTypes.SystemsV1Oauth2ClientCredentialsAuthPlugin{}
						if len(servicesItem.Credentials.Oauth2.AdditionalHeaders) > 0 {
							services1.Credentials.Oauth2.AdditionalHeaders = make(map[string]types.String)
							for key3, value1 := range servicesItem.Credentials.Oauth2.AdditionalHeaders {
								services1.Credentials.Oauth2.AdditionalHeaders[key3] = types.StringValue(value1)
							}
						}
						if len(servicesItem.Credentials.Oauth2.AdditionalParameters) > 0 {
							services1.Credentials.Oauth2.AdditionalParameters = make(map[string]types.String)
							for key4, value2 := range servicesItem.Credentials.Oauth2.AdditionalParameters {
								services1.Credentials.Oauth2.AdditionalParameters[key4] = types.StringValue(value2)
							}
						}
						services1.Credentials.Oauth2.ClientID = types.StringValue(servicesItem.Credentials.Oauth2.ClientID)
						services1.Credentials.Oauth2.ClientSecret = types.StringValue(servicesItem.Credentials.Oauth2.ClientSecret)
						services1.Credentials.Oauth2.GrantType = types.StringValue(servicesItem.Credentials.Oauth2.GrantType)
						services1.Credentials.Oauth2.IncludeJtiClaim = types.BoolValue(servicesItem.Credentials.Oauth2.IncludeJtiClaim)
						services1.Credentials.Oauth2.Scopes = []types.String{}
						for _, v := range servicesItem.Credentials.Oauth2.Scopes {
							services1.Credentials.Oauth2.Scopes = append(services1.Credentials.Oauth2.Scopes, types.StringValue(v))
						}
						services1.Credentials.Oauth2.SigningKey = types.StringValue(servicesItem.Credentials.Oauth2.SigningKey)
						services1.Credentials.Oauth2.Thumbprint = types.StringValue(servicesItem.Credentials.Oauth2.Thumbprint)
						services1.Credentials.Oauth2.TokenURL = types.StringValue(servicesItem.Credentials.Oauth2.TokenURL)
					}
					services1.Credentials.Plugin = types.StringPointerValue(servicesItem.Credentials.Plugin)
					if servicesItem.Credentials.S3Signing == nil {
						services1.Credentials.S3Signing = nil
					} else {
						services1.Credentials.S3Signing = &tfTypes.SystemsV1AwsSigningAuthPlugin{}
						if servicesItem.Credentials.S3Signing.EnvironmentCredentials == nil {
							services1.Credentials.S3Signing.EnvironmentCredentials = types.StringNull()
						} else {
							environmentCredentialsResult, _ := json.Marshal(servicesItem.Credentials.S3Signing.EnvironmentCredentials)
							services1.Credentials.S3Signing.EnvironmentCredentials = types.StringValue(string(environmentCredentialsResult))
						}
						if servicesItem.Credentials.S3Signing.MetadataCredentials == nil {
							services1.Credentials.S3Signing.MetadataCredentials = nil
						} else {
							services1.Credentials.S3Signing.MetadataCredentials = &tfTypes.SystemsV1BundleDistributionS3ConfigOpaCredentialsMetadataCredentials{}
							services1.Credentials.S3Signing.MetadataCredentials.AwsRegion = types.StringValue(servicesItem.Credentials.S3Signing.MetadataCredentials.AwsRegion)
							services1.Credentials.S3Signing.MetadataCredentials.IamRole = types.StringPointerValue(servicesItem.Credentials.S3Signing.MetadataCredentials.IamRole)
						}
						if servicesItem.Credentials.S3Signing.ProfileCredentials == nil {
							services1.Credentials.S3Signing.ProfileCredentials = nil
						} else {
							services1.Credentials.S3Signing.ProfileCredentials = &tfTypes.SystemsV1AwsProfileCredentialService{}
							services1.Credentials.S3Signing.ProfileCredentials.AwsRegion = types.StringValue(servicesItem.Credentials.S3Signing.ProfileCredentials.AwsRegion)
							services1.Credentials.S3Signing.ProfileCredentials.Path = types.StringPointerValue(servicesItem.Credentials.S3Signing.ProfileCredentials.Path)
							services1.Credentials.S3Signing.ProfileCredentials.Profile = types.StringPointerValue(servicesItem.Credentials.S3Signing.ProfileCredentials.Profile)
						}
						services1.Credentials.S3Signing.Service = types.StringPointerValue(servicesItem.Credentials.S3Signing.Service)
						if servicesItem.Credentials.S3Signing.WebIdentityCredentials == nil {
							services1.Credentials.S3Signing.WebIdentityCredentials = nil
						} else {
							services1.Credentials.S3Signing.WebIdentityCredentials = &tfTypes.SystemsV1BundleDistributionS3ConfigOpaCredentialsWebIdentityCredentials{}
							services1.Credentials.S3Signing.WebIdentityCredentials.AwsRegion = types.StringValue(servicesItem.Credentials.S3Signing.WebIdentityCredentials.AwsRegion)
							services1.Credentials.S3Signing.WebIdentityCredentials.SessionName = types.StringValue(servicesItem.Credentials.S3Signing.WebIdentityCredentials.SessionName)
						}
					}
				}
				if len(servicesItem.Headers) > 0 {
					services1.Headers = make(map[string]types.String)
					for key5, value3 := range servicesItem.Headers {
						services1.Headers[key5] = types.StringValue(value3)
					}
				}
				if len(servicesItem.Keys) > 0 {
					services1.Keys = make(map[string]tfTypes.KeysConfig)
					for keysConfigKey, keysConfigValue := range servicesItem.Keys {
						var keysConfigResult tfTypes.KeysConfig
						keysConfigResult.Algorithm = types.StringValue(keysConfigValue.Algorithm)
						keysConfigResult.Key = types.StringValue(keysConfigValue.Key)
						keysConfigResult.PrivateKey = types.StringValue(keysConfigValue.PrivateKey)
						keysConfigResult.Scope = types.StringValue(keysConfigValue.Scope)
						services1.Keys[keysConfigKey] = keysConfigResult
					}
				}
				services1.Name = types.StringValue(servicesItem.Name)
				services1.ResponseHeaderTimeoutSeconds = types.Int64PointerValue(servicesItem.ResponseHeaderTimeoutSeconds)
				if servicesItem.TLS == nil {
					services1.TLS = nil
				} else {
					services1.TLS = &tfTypes.SystemsV1ServerTLSConfig{}
					services1.TLS.CaCert = types.StringPointerValue(servicesItem.TLS.CaCert)
					services1.TLS.SystemCaRequired = types.BoolPointerValue(servicesItem.TLS.SystemCaRequired)
				}
				services1.Type = types.StringPointerValue(servicesItem.Type)
				services1.URL = types.StringValue(servicesItem.URL)
				if servicesCount+1 > len(r.Result.ExternalBundles.Services) {
					r.Result.ExternalBundles.Services = append(r.Result.ExternalBundles.Services, services1)
				} else {
					r.Result.ExternalBundles.Services[servicesCount].AllowInsecureTLS = services1.AllowInsecureTLS
					r.Result.ExternalBundles.Services[servicesCount].Credentials = services1.Credentials
					r.Result.ExternalBundles.Services[servicesCount].Headers = services1.Headers
					r.Result.ExternalBundles.Services[servicesCount].Keys = services1.Keys
					r.Result.ExternalBundles.Services[servicesCount].Name = services1.Name
					r.Result.ExternalBundles.Services[servicesCount].ResponseHeaderTimeoutSeconds = services1.ResponseHeaderTimeoutSeconds
					r.Result.ExternalBundles.Services[servicesCount].TLS = services1.TLS
					r.Result.ExternalBundles.Services[servicesCount].Type = services1.Type
					r.Result.ExternalBundles.Services[servicesCount].URL = services1.URL
				}
			}
		}
		r.Result.ExternalID = types.StringPointerValue(resp.Result.ExternalID)
		r.Result.FilterStacks = types.BoolPointerValue(resp.Result.FilterStacks)
		r.Result.ID = types.StringValue(resp.Result.ID)
		r.Result.KafkaTopic = types.StringPointerValue(resp.Result.KafkaTopic)
		r.Result.MatchingStacks = []types.String{}
		for _, v := range resp.Result.MatchingStacks {
			r.Result.MatchingStacks = append(r.Result.MatchingStacks, types.StringValue(v))
		}
		if resp.Result.Metadata.CreatedAt != nil {
			r.Result.Metadata.CreatedAt = types.StringValue(resp.Result.Metadata.CreatedAt.Format(time.RFC3339Nano))
		} else {
			r.Result.Metadata.CreatedAt = types.StringNull()
		}
		r.Result.Metadata.CreatedBy = types.StringPointerValue(resp.Result.Metadata.CreatedBy)
		r.Result.Metadata.CreatedThrough = types.StringPointerValue(resp.Result.Metadata.CreatedThrough)
		if resp.Result.Metadata.LastModifiedAt != nil {
			r.Result.Metadata.LastModifiedAt = types.StringValue(resp.Result.Metadata.LastModifiedAt.Format(time.RFC3339Nano))
		} else {
			r.Result.Metadata.LastModifiedAt = types.StringNull()
		}
		r.Result.Metadata.LastModifiedBy = types.StringPointerValue(resp.Result.Metadata.LastModifiedBy)
		r.Result.Metadata.LastModifiedThrough = types.StringPointerValue(resp.Result.Metadata.LastModifiedThrough)
		r.Result.MigrationHistory = []tfTypes.SystemsV1MigrationRecord{}
		if len(r.Result.MigrationHistory) > len(resp.Result.MigrationHistory) {
			r.Result.MigrationHistory = r.Result.MigrationHistory[:len(resp.Result.MigrationHistory)]
		}
		for migrationHistoryCount, migrationHistoryItem := range resp.Result.MigrationHistory {
			var migrationHistory1 tfTypes.SystemsV1MigrationRecord
			migrationHistory1.From = types.StringValue(migrationHistoryItem.From)
			migrationHistory1.InitiatedBy = types.StringValue(migrationHistoryItem.InitiatedBy)
			migrationHistory1.InitiatingUser = types.StringValue(migrationHistoryItem.InitiatingUser)
			migrationHistory1.MigratedAt = types.StringValue(migrationHistoryItem.MigratedAt.Format(time.RFC3339Nano))
			migrationHistory1.Recovered = types.BoolPointerValue(migrationHistoryItem.Recovered)
			migrationHistory1.To = types.StringValue(migrationHistoryItem.To)
			if migrationHistoryCount+1 > len(r.Result.MigrationHistory) {
				r.Result.MigrationHistory = append(r.Result.MigrationHistory, migrationHistory1)
			} else {
				r.Result.MigrationHistory[migrationHistoryCount].From = migrationHistory1.From
				r.Result.MigrationHistory[migrationHistoryCount].InitiatedBy = migrationHistory1.InitiatedBy
				r.Result.MigrationHistory[migrationHistoryCount].InitiatingUser = migrationHistory1.InitiatingUser
				r.Result.MigrationHistory[migrationHistoryCount].MigratedAt = migrationHistory1.MigratedAt
				r.Result.MigrationHistory[migrationHistoryCount].Recovered = migrationHistory1.Recovered
				r.Result.MigrationHistory[migrationHistoryCount].To = migrationHistory1.To
			}
		}
		r.Result.MinimumOpaVersion = types.StringPointerValue(resp.Result.MinimumOpaVersion)
		r.Result.MockOpaEnabled = types.BoolPointerValue(resp.Result.MockOpaEnabled)
		r.Result.Name = types.StringValue(resp.Result.Name)
		r.Result.Policies = []tfTypes.SystemsV1PolicyConfig{}
		if len(r.Result.Policies) > len(resp.Result.Policies) {
			r.Result.Policies = r.Result.Policies[:len(resp.Result.Policies)]
		}
		for policiesCount, policiesItem := range resp.Result.Policies {
			var policies1 tfTypes.SystemsV1PolicyConfig
			policies1.Created = types.StringPointerValue(policiesItem.Created)
			policies1.Enforcement.Enforced = types.BoolValue(policiesItem.Enforcement.Enforced)
			policies1.Enforcement.Type = types.StringValue(policiesItem.Enforcement.Type)
			policies1.ID = types.StringValue(policiesItem.ID)
			policies1.Modules = []tfTypes.SystemsV1Module{}
			for modulesCount, modulesItem := range policiesItem.Modules {
				var modules1 tfTypes.SystemsV1Module
				modules1.Name = types.StringValue(modulesItem.Name)
				modules1.Placeholder = types.BoolPointerValue(modulesItem.Placeholder)
				modules1.ReadOnly = types.BoolValue(modulesItem.ReadOnly)
				if modulesItem.Rules == nil {
					modules1.Rules = nil
				} else {
					modules1.Rules = &tfTypes.PoliciesV1RuleCounts{}
					modules1.Rules.Allow = types.Int64Value(int64(modulesItem.Rules.Allow))
					modules1.Rules.Deny = types.Int64Value(int64(modulesItem.Rules.Deny))
					modules1.Rules.Enforce = types.Int64Value(int64(modulesItem.Rules.Enforce))
					modules1.Rules.Ignore = types.Int64Value(int64(modulesItem.Rules.Ignore))
					modules1.Rules.Monitor = types.Int64Value(int64(modulesItem.Rules.Monitor))
					modules1.Rules.Notify = types.Int64Value(int64(modulesItem.Rules.Notify))
					modules1.Rules.Other = types.Int64Value(int64(modulesItem.Rules.Other))
					modules1.Rules.Test = types.Int64Value(int64(modulesItem.Rules.Test))
					modules1.Rules.Total = types.Int64Value(int64(modulesItem.Rules.Total))
				}
				if modulesCount+1 > len(policies1.Modules) {
					policies1.Modules = append(policies1.Modules, modules1)
				} else {
					policies1.Modules[modulesCount].Name = modules1.Name
					policies1.Modules[modulesCount].Placeholder = modules1.Placeholder
					policies1.Modules[modulesCount].ReadOnly = modules1.ReadOnly
					policies1.Modules[modulesCount].Rules = modules1.Rules
				}
			}
			if policiesItem.Rules == nil {
				policies1.Rules = nil
			} else {
				policies1.Rules = &tfTypes.PoliciesV1RuleCounts{}
				policies1.Rules.Allow = types.Int64Value(int64(policiesItem.Rules.Allow))
				policies1.Rules.Deny = types.Int64Value(int64(policiesItem.Rules.Deny))
				policies1.Rules.Enforce = types.Int64Value(int64(policiesItem.Rules.Enforce))
				policies1.Rules.Ignore = types.Int64Value(int64(policiesItem.Rules.Ignore))
				policies1.Rules.Monitor = types.Int64Value(int64(policiesItem.Rules.Monitor))
				policies1.Rules.Notify = types.Int64Value(int64(policiesItem.Rules.Notify))
				policies1.Rules.Other = types.Int64Value(int64(policiesItem.Rules.Other))
				policies1.Rules.Test = types.Int64Value(int64(policiesItem.Rules.Test))
				policies1.Rules.Total = types.Int64Value(int64(policiesItem.Rules.Total))
			}
			policies1.Type = types.StringValue(policiesItem.Type)
			if policiesCount+1 > len(r.Result.Policies) {
				r.Result.Policies = append(r.Result.Policies, policies1)
			} else {
				r.Result.Policies[policiesCount].Created = policies1.Created
				r.Result.Policies[policiesCount].Enforcement = policies1.Enforcement
				r.Result.Policies[policiesCount].ID = policies1.ID
				r.Result.Policies[policiesCount].Modules = policies1.Modules
				r.Result.Policies[policiesCount].Rules = policies1.Rules
				r.Result.Policies[policiesCount].Type = policies1.Type
			}
		}
		r.Result.ReadOnly = types.BoolPointerValue(resp.Result.ReadOnly)
		if resp.Result.SourceControl == nil {
			r.Result.SourceControl = nil
		} else {
			r.Result.SourceControl = &tfTypes.GitV1SourceControlConfig{}
			r.Result.SourceControl.Origin.Commit = types.StringValue(resp.Result.SourceControl.Origin.Commit)
			r.Result.SourceControl.Origin.Credentials = types.StringValue(resp.Result.SourceControl.Origin.Credentials)
			r.Result.SourceControl.Origin.Path = types.StringValue(resp.Result.SourceControl.Origin.Path)
			r.Result.SourceControl.Origin.Reference = types.StringValue(resp.Result.SourceControl.Origin.Reference)
			if resp.Result.SourceControl.Origin.SSHCredentials == nil {
				r.Result.SourceControl.Origin.SSHCredentials = nil
			} else {
				r.Result.SourceControl.Origin.SSHCredentials = &tfTypes.GitV1SSHCredentials{}
				r.Result.SourceControl.Origin.SSHCredentials.Passphrase = types.StringValue(resp.Result.SourceControl.Origin.SSHCredentials.Passphrase)
				r.Result.SourceControl.Origin.SSHCredentials.PrivateKey = types.StringValue(resp.Result.SourceControl.Origin.SSHCredentials.PrivateKey)
			}
			r.Result.SourceControl.Origin.URL = types.StringValue(resp.Result.SourceControl.Origin.URL)
		}
		r.Result.Status = types.StringValue(resp.Result.Status)
		r.Result.Tokens = []tfTypes.TokensV1Token{}
		if len(r.Result.Tokens) > len(resp.Result.Tokens) {
			r.Result.Tokens = r.Result.Tokens[:len(resp.Result.Tokens)]
		}
		for tokensCount, tokensItem := range resp.Result.Tokens {
			var tokens1 tfTypes.TokensV1Token
			tokens1.AllowPathPatterns = []types.String{}
			for _, v := range tokensItem.AllowPathPatterns {
				tokens1.AllowPathPatterns = append(tokens1.AllowPathPatterns, types.StringValue(v))
			}
			tokens1.Description = types.StringValue(tokensItem.Description)
			if tokensItem.Expires != nil {
				tokens1.Expires = types.StringValue(tokensItem.Expires.Format(time.RFC3339Nano))
			} else {
				tokens1.Expires = types.StringNull()
			}
			tokens1.ID = types.StringValue(tokensItem.ID)
			if tokensItem.Metadata.CreatedAt != nil {
				tokens1.Metadata.CreatedAt = types.StringValue(tokensItem.Metadata.CreatedAt.Format(time.RFC3339Nano))
			} else {
				tokens1.Metadata.CreatedAt = types.StringNull()
			}
			tokens1.Metadata.CreatedBy = types.StringPointerValue(tokensItem.Metadata.CreatedBy)
			tokens1.Metadata.CreatedThrough = types.StringPointerValue(tokensItem.Metadata.CreatedThrough)
			if tokensItem.Metadata.LastModifiedAt != nil {
				tokens1.Metadata.LastModifiedAt = types.StringValue(tokensItem.Metadata.LastModifiedAt.Format(time.RFC3339Nano))
			} else {
				tokens1.Metadata.LastModifiedAt = types.StringNull()
			}
			tokens1.Metadata.LastModifiedBy = types.StringPointerValue(tokensItem.Metadata.LastModifiedBy)
			tokens1.Metadata.LastModifiedThrough = types.StringPointerValue(tokensItem.Metadata.LastModifiedThrough)
			tokens1.Token = types.StringPointerValue(tokensItem.Token)
			tokens1.TTL = types.StringValue(tokensItem.TTL)
			tokens1.Uses = types.Int64PointerValue(tokensItem.Uses)
			if tokensCount+1 > len(r.Result.Tokens) {
				r.Result.Tokens = append(r.Result.Tokens, tokens1)
			} else {
				r.Result.Tokens[tokensCount].AllowPathPatterns = tokens1.AllowPathPatterns
				r.Result.Tokens[tokensCount].Description = tokens1.Description
				r.Result.Tokens[tokensCount].Expires = tokens1.Expires
				r.Result.Tokens[tokensCount].ID = tokens1.ID
				r.Result.Tokens[tokensCount].Metadata = tokens1.Metadata
				r.Result.Tokens[tokensCount].Token = tokens1.Token
				r.Result.Tokens[tokensCount].TTL = tokens1.TTL
				r.Result.Tokens[tokensCount].Uses = tokens1.Uses
			}
		}
		r.Result.Type = types.StringValue(resp.Result.Type)
		if resp.Result.TypeParameters == nil {
			r.Result.TypeParameters = nil
		} else {
			r.Result.TypeParameters = &tfTypes.TypeParameters{}
		}
		if len(resp.Result.Uninstall) > 0 {
			r.Result.Uninstall = make(map[string]types.String)
			for key7, value4 := range resp.Result.Uninstall {
				r.Result.Uninstall[key7] = types.StringValue(value4)
			}
		}
	}
}
